<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>vcd.core API documentation</title>
<meta name="description" content="VCD (Video Content Description) library v4.3.0 â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>vcd.core</code></h1>
</header>
<section id="section-intro">
<p>VCD (Video Content Description) library v4.3.0</p>
<p>Project website: <a href="http://vcd.vicomtech.org">http://vcd.vicomtech.org</a></p>
<p>Copyright (C) 2020, Vicomtech (<a href="http://www.vicomtech.es/">http://www.vicomtech.es/</a>),
(Spain) all rights reserved.</p>
<p>VCD is a Python library to create and manage VCD content version 4.3.0.
VCD is distributed under MIT License. See LICENSE.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
VCD (Video Content Description) library v4.3.0

Project website: http://vcd.vicomtech.org

Copyright (C) 2020, Vicomtech (http://www.vicomtech.es/),
(Spain) all rights reserved.

VCD is a Python library to create and manage VCD content version 4.3.0.
VCD is distributed under MIT License. See LICENSE.

&#34;&#34;&#34;


import copy
import json
import warnings
from jsonschema import validate
from enum import Enum

import re
import uuid

import vcd.types as types
import vcd.utils as utils
import vcd.schema as schema
import vcd.converter as converter


class ElementType(Enum):
    &#34;&#34;&#34;
    Elements of VCD (Object, Action, Event, Context, Relation)
    &#34;&#34;&#34;
    object = 1
    action = 2
    event = 3
    context = 4
    relation = 5


class StreamType(Enum):
    &#34;&#34;&#34;
    Type of stream (sensor).
    &#34;&#34;&#34;
    camera = 1
    lidar = 2
    radar = 3
    gps_imu = 4
    other = 5


class RDF(Enum):
    &#34;&#34;&#34;
    Type of RDF agent (subject or object)
    &#34;&#34;&#34;
    subject = 1
    object = 2


class FrameIntervals:
    &#34;&#34;&#34;
    FrameIntervals class aims to simplify management of frame intervals
    &#34;&#34;&#34;
    def __init__(self, frame_value=None):
        self.fis_dict = []
        self.fis_num = []

        if frame_value is not None:
            if isinstance(frame_value, int):
                self.fis_dict = [{&#39;frame_start&#39;: frame_value, &#39;frame_end&#39;: frame_value}]
                self.fis_num = [(frame_value, frame_value)]
            elif isinstance(frame_value, list):
                if len(frame_value) == 0:
                    return
                if all(isinstance(x, tuple) for x in frame_value):
                    # Then, frame_value is an array of tuples
                    self.fis_dict = utils.as_frame_intervals_array_dict(frame_value)
                    self.fis_dict = utils.fuse_frame_intervals(self.fis_dict)
                    self.fis_num = utils.as_frame_intervals_array_tuples(self.fis_dict)
                elif all(isinstance(x, list) for x in frame_value):
                    # This is possibly a list of list, e.g. [[0, 10], [12, 15]], instead of the above case list of tupl
                    self.fis_dict = utils.as_frame_intervals_array_dict(frame_value)
                    self.fis_dict = utils.fuse_frame_intervals(self.fis_dict)
                    self.fis_num = utils.as_frame_intervals_array_tuples(self.fis_dict)
                elif all(isinstance(x, dict) for x in frame_value):
                    # User provided a list of dict
                    self.fis_dict = frame_value
                    self.fis_dict = utils.fuse_frame_intervals(self.fis_dict)
                    self.fis_num = utils.as_frame_intervals_array_tuples(self.fis_dict)
            elif isinstance(frame_value, tuple):
                # Then, frame_value is a tuple (one single frame interval)
                self.fis_num = [frame_value]
                self.fis_dict = utils.as_frame_intervals_array_dict(self.fis_num)
            elif isinstance(frame_value, dict):
                # User provided a single dict
                self.fis_dict = [frame_value]
                self.fis_num = utils.as_frame_intervals_array_tuples(self.fis_dict)
            else:
                warnings.warn(&#34;ERROR: Unsupported FrameInterval format.&#34;)

    def empty(self):
        if len(self.fis_dict) == 0 or len(self.fis_num) == 0:
            return True
        else:
            return False

    def get_dict(self):
        return self.fis_dict

    def get(self):
        return self.fis_num

    def get_length(self):
        length = 0
        for fi in self.fis_num:
            length += fi[1] + 1 - fi[0]
        return length

    def rm_frame(self, frame_num):
        self.fis_dict = utils.rm_frame_from_frame_intervals(self.fis_dict, frame_num)
        self.fis_num = utils.as_frame_intervals_array_tuples(self.fis_dict)

    def union(self, frame_intervals):
        fis_union = utils.fuse_frame_intervals(frame_intervals.get_dict() + self.fis_dict)
        return FrameIntervals(fis_union)

    def intersection(self, frame_intervals):
        fis_int = utils.intersection_between_frame_interval_arrays(self.fis_num, frame_intervals.get())
        return FrameIntervals(fis_int)

    def equals(self, frame_intervals):
        fis_int = self.intersection(frame_intervals)
        fis_union = self.union(frame_intervals)

        if fis_int.get_length() == fis_union.get_length():
            return True
        else:
            return False

    def contains(self, frame_intervals):
        fis_int = self.intersection(frame_intervals)

        if fis_int.get_length() == frame_intervals.get_length():
            return True
        else:
            return False

    def is_contained_by(self, frame_intervals):
        fis_int = self.intersection(frame_intervals)

        if fis_int.get_length() == self.get_length():
            return True
        else:
            return False

    def get_outer(self):
        return utils.get_outer_frame_interval(self.fis_dict)

    def has_frame(self, frame_num):
        return utils.is_inside_frame_intervals(frame_num, self.fis_num)

    def to_str(self):
        text = &#34;[&#34;
        for fi in self.fis_num:
            text += &#34;(&#34; + str(fi[0]) + &#34;,&#34; + str(fi[1]) + &#34;)&#34;
        text += &#34;]&#34;

        return text


class UID:
    &#34;&#34;&#34;
    This is a helper class that simplifies management of UIDs.
    Public functions permits the user to introduce either int or string values as UIDs
    Internal functions create the UID objects to ensure the proper format is used where needed
    &#34;&#34;&#34;
    def __init__(self, val=None):
        if val is None:
            # Void uid
            self.__set(&#34;&#34;, -1, False)
        else:
            if isinstance(val, int):
                self.__set(str(val), val, False)
            elif isinstance(val, str):
                if val == &#39;&#39;:
                    self.__set(&#34;&#34;, -1, False)
                else:
                    if val.strip(&#39;-&#39;).isnumeric():  # this holds true for &#34;-3&#34; and &#34;3&#34;
                        self.__set(val, int(val), False)
                    elif bool(re.match(r&#34;^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$&#34;,
                                       val)):
                        self.__set(val, -1, True)
                    else:
                        warnings.warn(&#34;ERROR: Unsupported UID string type.&#34;)
                        self.__set(&#34;&#34;, -1, False)
            else:
                warnings.warn(&#34;ERROR: Unsupported UID type.&#34;)
                self.__set(&#34;&#34;, -1, False)

    def __set(self, uid_str=None, uid_int=None, is_uuid=False):
        self.uid_str = uid_str
        self.uid_int = uid_int
        self.uuid = is_uuid

    def is_uuid(self):
        return self.uuid

    def as_str(self):
        return self.uid_str

    def as_int(self):
        if self.is_uuid():
            warnings.warn(&#34;ERROR: This UID is not numeric, can&#39;t call getAsInt.&#34;)
        else:
            return self.uid_int

    def is_none(self):
        if self.uid_int == -1 and self.uid_str == &#34;&#34;:
            return True
        else:
            return False


class SetMode(Enum):
    &#34;&#34;&#34;
    The SetMode specifies how added content is inserted.
    SetMode.union is the default value,
    and determines that any new call to add functions (e.g. add_object, or add_action_data),
    actually adds content, extending the frame_intervals of the recipient container to the
    limits defined by the newly provided frame_intervals, effectively extending it to the union
    of frame_intervals (existing plus new), substituting the content which already existed
    with coincident frame (and name, uid, etc).
    SetMode.replace acts replacing old content by new, potentially removing frames if the newly
    provided frame_intervals are shorter than the existing ones.
    &#34;&#34;&#34;
    union = 1
    replace = 2


class VCD:
    &#34;&#34;&#34;
    VCD class as main container of VCD content. Exposes functions to
    add Elements, to get information and to remove data.
    Internally manages all information as Python dictionaries, and can map
    data into JSON strings.
    &#34;&#34;&#34;
    ##################################################
    # Constructor
    ##################################################
    def __init__(self, file_name=None, validation=False):
        self.use_uuid = False
        if file_name is not None:
            json_file = open(file_name)
            # In VCD 4.2.0, uids and frames were ints, so, parsing needed a lambda function to do the job
            # self.data = json.load(
            #    json_file,
            #    object_hook=lambda d: {int(k) if k.lstrip(&#39;-&#39;).isdigit() else k: v for k, v in d.items()}
            # )

            read_data = json.load(json_file)  # Open without converting strings to integers
            # Check VERSION
            if &#39;vcd&#39; in read_data:
                # This is 4.x
                if &#39;version&#39; in read_data[&#39;vcd&#39;]:
                    # This is 4.1-2
                    if read_data[&#39;vcd&#39;][&#39;version&#39;] == &#34;4.2.0&#34;:
                        # This is VCD 4.2.0
                        warnings.warn(&#34;WARNING: Converting VCD 4.2.0 to VCD 4.3.0. A full revision is recommended.&#34;)
                        # Convert frame entries to int
                        frames = read_data[&#39;vcd&#39;][&#39;frames&#39;]
                        if frames:  # So frames is not empty
                            read_data[&#39;vcd&#39;][&#39;frames&#39;] = {int(key): value for key, value in frames.items()}

                        self.reset()  # to init object
                        converter.ConverterVCD420toVCD430(read_data, self)  # self is modified internally

                    elif read_data[&#39;vcd&#39;][&#39;version&#39;] == &#34;4.1.0&#34;:
                        # This is VCD 4.1.0
                        raise Exception(&#34;ERROR: VCD 4.1.0 to VCD 4.3.0 conversion is not implemented.&#34;)
                        pass
                elif &#39;metadata&#39; in read_data[&#39;vcd&#39;]:
                    if &#39;schema_version&#39; in read_data[&#39;vcd&#39;][&#39;metadata&#39;]:
                        if read_data[&#39;vcd&#39;][&#39;metadata&#39;][&#39;schema_version&#39;] == &#34;4.3.0&#34;:
                            # This is VCD 4.3.0
                            self.data = read_data
                            if validation:
                                if not hasattr(self, &#39;schema&#39;):
                                    self.schema = schema.vcd_schema
                                validate(instance=self.data, schema=self.schema)  # Raises errors if not validated
                                json_file.close()

                            # In VCD 4.3.0 uids are strings, because they can be numeric strings, or UUIDs
                            # but frames are still ints, so let&#39;s parse like that
                            if &#39;frames&#39; in self.data[&#39;vcd&#39;]:
                                frames = self.data[&#39;vcd&#39;][&#39;frames&#39;]
                                if frames:  # So frames is not empty
                                    self.data[&#39;vcd&#39;][&#39;frames&#39;] = {int(key): value for key, value in frames.items()}
                        else:
                            raise Exception(&#34;ERROR: This vcd file does not seem to be 4.3.0 nor 4.2.0&#34;)
                    else:
                        raise Exception(&#34;ERROR: This vcd file does not seem to be 4.3.0 nor 4.2.0&#34;)
            elif &#39;VCD&#39; in read_data:
                # This is 3.x
                warnings.warn(&#34;WARNING: Converting VCD 3.3.0 to VCD 4.3.0. A full revision is recommended.&#34;)
                # Assuming this is VCD 3.3.0, let&#39;s load into VCD 4.3.0
                self.reset()  # to init object
                converter.ConverterVCD330toVCD430(read_data, self)  # self is modified internally

            # Close file
            json_file.close()

            # Final set-up
            self.__compute_last_uid()
        else:
            self.reset()

    def set_use_uuid(self, val):
        assert(isinstance(val, bool))
        self.use_uuid = val

    def reset(self):
        # Main VCD data
        self.data = {&#39;vcd&#39;: {}}
        self.data[&#39;vcd&#39;][&#39;metadata&#39;] = {}
        self.data[&#39;vcd&#39;][&#39;metadata&#39;][&#39;schema_version&#39;] = schema.vcd_schema_version

        # Schema information
        self.schema = schema.vcd_schema

        # Additional auxiliary structures
        self.__lastUID = dict()
        self.__lastUID[ElementType.object] = -1
        self.__lastUID[ElementType.action] = -1
        self.__lastUID[ElementType.event] = -1
        self.__lastUID[ElementType.context] = -1
        self.__lastUID[ElementType.relation] = -1

    def convert_to_vcd330(self):
        return converter.ConverterVCD430toVCD330(self.data)

    ##################################################
    # Private API: inner functions
    ##################################################
    def __get_uid_to_assign(self, element_type, uid):
        assert isinstance(element_type, ElementType)
        assert(isinstance(uid, UID))
        if uid.is_none():
            if self.use_uuid:
                # Let&#39;s use UUIDs
                uid_to_assign = UID(str(uuid.uuid4()))
            else:
                # Let&#39;s use integers
                self.__lastUID[element_type] += 1
                uid_to_assign = UID(self.__lastUID[element_type])
        else:
            # uid is not None
            assert(isinstance(uid, UID))
            if not uid.is_uuid():
                # Ok, user provided a number, let&#39;s proceed
                if uid.as_int() &gt; self.__lastUID[element_type]:
                    self.__lastUID[element_type] = uid.as_int()
                    uid_to_assign = UID(self.__lastUID[element_type])
                else:
                    uid_to_assign = uid
            else:
                # This is a UUID
                self.use_uuid = True
                uid_to_assign = uid

        return uid_to_assign

    def __set_vcd_frame_intervals(self, frame_intervals):
        assert(isinstance(frame_intervals, FrameIntervals))
        if not frame_intervals.empty():
            self.data[&#39;vcd&#39;][&#39;frame_intervals&#39;] = frame_intervals.get_dict()

    def __update_vcd_frame_intervals(self, frame_intervals):
        # This function creates the union of existing VCD with the input frameIntervals
        assert (isinstance(frame_intervals, FrameIntervals))
        if not frame_intervals.empty():
            if &#39;frame_intervals&#39; not in self.data[&#39;vcd&#39;]:
                self.data[&#39;vcd&#39;][&#39;frame_intervals&#39;] = []
            fis_current = FrameIntervals(self.data[&#39;vcd&#39;][&#39;frame_intervals&#39;])
            fis_union = fis_current.union(frame_intervals)
            self.__set_vcd_frame_intervals(fis_union)

    def __add_frame(self, frame_num):
        if &#39;frames&#39; not in self.data[&#39;vcd&#39;]:
            self.data[&#39;vcd&#39;][&#39;frames&#39;] = {}
        if frame_num not in self.data[&#39;vcd&#39;][&#39;frames&#39;]:
            self.data[&#39;vcd&#39;][&#39;frames&#39;][frame_num] = {}

    def __compute_last_uid(self):
        self.__lastUID = dict()
        # Read all objects and fill lastUID
        self.__lastUID[ElementType.object] = -1
        if &#39;objects&#39; in self.data[&#39;vcd&#39;]:
            for uid in self.data[&#39;vcd&#39;][&#39;objects&#39;]:
                if int(uid) &gt; self.__lastUID[ElementType.object]:
                    self.__lastUID[ElementType.object] = int(uid)

        self.__lastUID[ElementType.action] = -1
        if &#39;actions&#39; in self.data[&#39;vcd&#39;]:
            for uid in self.data[&#39;vcd&#39;][&#39;actions&#39;]:
                if int(uid) &gt; self.__lastUID[ElementType.action]:
                    self.__lastUID[ElementType.action] = int(uid)

        self.__lastUID[ElementType.event] = -1
        if &#39;events&#39; in self.data[&#39;vcd&#39;]:
            for uid in self.data[&#39;vcd&#39;][&#39;events&#39;]:
                if int(uid) &gt; self.__lastUID[ElementType.event]:
                    self.__lastUID[ElementType.event] = int(uid)

        self.__lastUID[ElementType.context] = -1
        if &#39;contexts&#39; in self.data[&#39;vcd&#39;]:
            for uid in self.data[&#39;vcd&#39;][&#39;contexts&#39;]:
                if int(uid) &gt; self.__lastUID[ElementType.context]:
                    self.__lastUID[ElementType.context] = int(uid)

        self.__lastUID[ElementType.relation] = -1
        if &#39;relations&#39; in self.data[&#39;vcd&#39;]:
            for uid in self.data[&#39;vcd&#39;][&#39;relations&#39;]:
                if int(uid) &gt; self.__lastUID[ElementType.relation]:  # uid is a string!
                    self.__lastUID[ElementType.relation] = int(uid)

    def __add_frames(self, frame_intervals, element_type, uid):
        assert(isinstance(frame_intervals, FrameIntervals))
        assert(isinstance(element_type, ElementType))
        assert(isinstance(uid, UID))
        if frame_intervals.empty():
            return
        else:
            # Loop over frames and add
            fis = frame_intervals.get()
            for fi in fis:
                for f in range(fi[0], fi[1]+1):
                    # Add frame
                    self.__add_frame(f)
                    # Add element entry
                    frame = self.get_frame(f)
                    frame.setdefault(element_type.name + &#39;s&#39;, {})
                    frame[element_type.name + &#39;s&#39;].setdefault(uid.as_str(), {})

    def __set_element(
            self, element_type, name, semantic_type, frame_intervals, uid, ont_uid,
            coordinate_system, set_mode
    ):
        assert (isinstance(uid, UID))
        assert (isinstance(ont_uid, UID))
        assert (isinstance(frame_intervals, FrameIntervals))
        assert (isinstance(set_mode, SetMode))

        fis = frame_intervals
        if set_mode == SetMode.union:
            # Union means fusion, we are calling this function to &#34;add&#34; content, not to remove any
            fis_existing = self.get_element_frame_intervals(element_type, uid.as_str())
            fis = fis_existing.union(frame_intervals)

        # 0.- Get uid_to_assign
        uid_to_assign = self.__get_uid_to_assign(element_type, uid)  # note: private functions use UID type for uids

        # 1.- Set the root entries and frames entries
        self.__set_element_at_root_and_frames(element_type, name, semantic_type, fis,
                                              uid_to_assign, ont_uid, coordinate_system)

        return uid_to_assign

    def __set_element_at_root_and_frames(
            self, element_type, name, semantic_type, frame_intervals, uid, ont_uid, coordinate_system
    ):
        # 1.- Copy from existing or create new entry (this copies everything, including element_data)
        # element_data_pointers and frame intervals
        uidstr = uid.as_str()
        element_existed = self.has(element_type, uidstr)# note: public functions use int or str for uids
        self.data[&#39;vcd&#39;].setdefault(element_type.name + &#39;s&#39;, {})
        self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;].setdefault(uidstr, {})
        element = self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;][uidstr]

        fis_old = FrameIntervals()
        if &#39;frame_intervals&#39; in element:
            fis_old = FrameIntervals(element[&#39;frame_intervals&#39;])

        # 2.- Copy from arguments
        if name is not None:
            element[&#39;name&#39;] = name
        if semantic_type is not None:
            element[&#39;type&#39;] = semantic_type
        if not frame_intervals.empty() or (element_existed and not fis_old.empty()):
            # So, either the newFis has something, or the fisOld had something (in which case needs to be substituted)
            # Under the previous control, no &#39;frame_intervals&#39; field is added to newly created static elements
            # -&gt; should &#39;frame_intervals&#39; be mandatory
            element[&#39;frame_intervals&#39;] = frame_intervals.get_dict()
        if not ont_uid.is_none() and self.get_ontology(ont_uid.as_str()):
            element[&#39;ontology_uid&#39;] = ont_uid.as_str()
        if coordinate_system is not None and self.has_coordinate_system(coordinate_system):
            element[&#39;coordinate_system&#39;] = coordinate_system

        # 2.bis.- For Relations obligue to have rdf_objects and rdf_subjects entries (to be compliant with schema)
        if element_type is ElementType.relation:
            if &#39;rdf_subjects&#39; not in element:
                element[&#39;rdf_subjects&#39;] = []
            if &#39;rdf_objects&#39; not in element:
                element[&#39;rdf_objects&#39;] = []

        # 3.- Reshape element_data_pointers according to this new frame intervals
        if element_type.name + &#39;_data_pointers&#39; in element:
            edps = element[element_type.name + &#39;_data_pointers&#39;]
            for edp_name in edps:
                # NOW, we have to UPDATE frame intervals of pointers because we have modified the frame_intervals
                # of the element itself, adn
                # If we compute the intersection frame_intervals, we can copy that into
                # element_data_pointers frame intervals
                fis_int = FrameIntervals()
                if not frame_intervals.empty():
                    fis_int = frame_intervals.intersection(FrameIntervals(edps[edp_name][&#39;frame_intervals&#39;]))

                # Update the pointers
                element.setdefault(element_type.name + &#39;_data_pointers&#39;, {})
                element[element_type.name + &#39;_data_pointers&#39;][edp_name] = edps[edp_name]
                element[element_type.name + &#39;_data_pointers&#39;][edp_name][&#39;frame_intervals&#39;] = fis_int.get_dict()

        # 4.- Now set at frames
        if not frame_intervals.empty():
            # 2.1.- There is frame_intervals specified
            if not element_existed:
                # 2.1.a) Just create the new element
                self.__add_frames(frame_intervals, element_type, uid)
                self.__update_vcd_frame_intervals(frame_intervals)
            else:
                # 2.1.b) This is a substitution: depending on the new frame_intervals, we may need to delete/add frames
                # Add
                fis_new = frame_intervals
                for fi in fis_new.get():
                    for f in range(fi[0], fi[1] + 1):
                        is_inside = fis_old.has_frame(f)
                        if not is_inside:
                            # New frame is not inside -&gt; let&#39;s add this frame
                            fi_ = FrameIntervals(f)
                            self.__add_frames(fi_, element_type, uid)
                            self.__update_vcd_frame_intervals(fi_)
                # Remove
                if element_existed and fis_old.empty():
                    # Ok, the element was originally static (thus with fisOld empty)
                    # so potentially there are pointers of the element in all frames (in case there are frames)
                    # Now the element is declared with a specific frame intervals. Then we first need to remove all
                    # element entries (pointers) in all OTHER frames
                    vcd_frame_intervals = self.get_frame_intervals()
                    if not vcd_frame_intervals.empty():
                        for fi in vcd_frame_intervals.get():
                            for f in range(fi[0], fi[1] + 1):
                                if not fis_new.has_frame(f):  # Only for those OTHER frames not those just added
                                    elements_in_frame = self.data[&#39;vcd&#39;][&#39;frames&#39;][f][element_type.name + &#39;s&#39;]
                                    if uidstr in elements_in_frame:
                                        del elements_in_frame[uidstr]
                                        if len(elements_in_frame) == 0:
                                            del self.data[&#39;vcd&#39;][&#39;frames&#39;][f][element_type.name + &#39;s&#39;]
                                            if len(self.data[&#39;vcd&#39;][&#39;frames&#39;][f]) == 0:
                                                self.__rm_frame(f)

                # Next loop for is for the case fis_old wasn&#39;t empty, so we just need to remove old content
                for fi in fis_old.get():
                    for f in range(fi[0], fi[1] + 1):
                        is_inside = fis_new.has_frame(f)
                        if not is_inside:
                            # Old frame not inside new ones -&gt; let&#39;s remove this frame
                            elements_in_frame = self.data[&#39;vcd&#39;][&#39;frames&#39;][f][element_type.name + &#39;s&#39;]
                            del elements_in_frame[uidstr]
                            if len(elements_in_frame) == 0:
                                del self.data[&#39;vcd&#39;][&#39;frames&#39;][f][element_type.name + &#39;s&#39;]
                                if len(self.data[&#39;vcd&#39;][&#39;frames&#39;][f]) == 0:
                                    self.__rm_frame(f)
        else:
            # 2.2.- The element is declared as static
            if element_type is not ElementType.relation:  # frame-less relation must remain frame-less
                vcd_frame_intervals = self.get_frame_intervals()
                if not vcd_frame_intervals.empty():
                    # ... but VCD has already other elements or info that have established some frame intervals
                    # The element is then assumed to exist in all frames: let&#39;s add a pointer into all frames
                    self.__add_frames(vcd_frame_intervals, element_type, uid)

            # But, if the element existed previously, and it was dynamic, there is already information inside frames.
            # If there is element_data at frames, they are removed
            if not fis_old.empty():
                self.rm_element_data_from_frames(element_type, uid, fis_old)

                # Additionally, we need to remove element entries at frames, and frames entirely to clean-up
                for fi in fis_old.get():
                    for f in range(fi[0], fi[1] + 1):
                        elements_in_frame = self.data[&#39;vcd&#39;][&#39;frames&#39;][f][element_type.name + &#39;s&#39;]
                        del elements_in_frame[uidstr]
                        # Clean-up
                        if len(elements_in_frame) == 0:
                            del self.data[&#39;vcd&#39;][&#39;frames&#39;][f][element_type.name + &#39;s&#39;]
                            if len(self.data[&#39;vcd&#39;][&#39;frames&#39;][f]) == 0:
                                self.__rm_frame(f)

    def __set_element_data(self, element_type, uid, element_data, frame_intervals, set_mode):
        assert(isinstance(uid, UID))
        assert(isinstance(frame_intervals, FrameIntervals))
        assert(isinstance(set_mode, SetMode))

        # 0.- Checks
        if not self.has(element_type, uid.as_str()):
            warnings.warn(&#34;WARNING: Trying to set element_data for a non-existing element.&#34;)
            return
        element = self.get_element(element_type, uid.as_str())

        # Read existing data about this element, so we can call __set_element
        name = element[&#39;name&#39;]
        semantic_type = element[&#39;type&#39;]
        ont_uid = UID(None)
        cs = None
        if &#39;ontology_uid&#39; in element:
            ont_uid = UID(element[&#39;ontology_uid&#39;])
        if &#39;coordinate_system&#39; in element:
            cs = element[&#39;coordinate_system&#39;]

        if &#39;coordinate_system&#39; in element_data.data:
            if not self.has_coordinate_system(element_data.data[&#39;coordinate_system&#39;]):
                warnings.warn(&#34;WARNING: Trying to set element_data with a non-declared coordinate system.&#34;)
                return

        if frame_intervals.empty() and set_mode == SetMode.union and not isinstance(element_data, types.mesh):
            set_mode = SetMode.replace

        if set_mode == SetMode.replace:
            # Extend also the container Element just in case the frame_interval of this element_data is beyond it
            # removes/creates frames if needed
            # This call is to modify an existing element_data, which may imply removing some frames
            if not frame_intervals.empty():
                fis_existing = FrameIntervals(element[&#39;frame_intervals&#39;])
                fis_new = frame_intervals
                fis_union = fis_existing.union(fis_new)
                self.__set_element(element_type, name, semantic_type, fis_union, uid, ont_uid, cs, set_mode)
                self.__set_element_data_content_at_frames(element_type, uid, element_data, frame_intervals)
            else:
                # This is a static element_data. If it was declared dynamic before, let&#39;s remove it
                #self.__set_element(element_type, name, semantic_type, frame_intervals, uid, ont_uid, cs, set_mode)
                if self.has_element_data(element_type, uid.as_str(), element_data):
                    fis_old = self.get_element_data_frame_intervals(element_type, uid.as_str(), element_data.data[&#39;name&#39;])
                    if not fis_old.empty():
                        self.rm_element_data_from_frames_by_name(element_type, uid, element_data.data[&#39;name&#39;], fis_old)
                self.__set_element_data_content(element_type, element, element_data)
            # Set the pointers
            self.__set_element_data_pointers(element_type, uid, element_data, frame_intervals)
        else:  # set_mode = SetMode.union
            # This call is to add element_data to the element, substituting content if overlap, otherwise adding
            # First, extend also the container Element just in case the frame_interval of this element_data is beyond
            # the currently existing frame_intervals of the Element
            # internally computes the union
            self.__set_element(element_type, name, semantic_type, frame_intervals, uid, ont_uid, cs, set_mode)

            if not frame_intervals.empty():
                fis_existing = FrameIntervals()
                if element_type.name + &#39;_data_pointers&#39; in element:
                    edp = element[element_type.name + &#39;_data_pointers&#39;]
                    if element_data.data[&#39;name&#39;] in edp:
                        fis_existing = FrameIntervals(edp[element_data.data[&#39;name&#39;]][&#39;frame_intervals&#39;])
                fis_new = frame_intervals
                fis_union = fis_existing.union(fis_new)

                # Dynamic
                if element is not None:
                    # It is not a simple call with the union of frame intervals
                    # We need to substitute the content for just this frame_interval, without modifying the rest
                    # that must stay as it was
                    # Loop over the specified frame_intervals to create or substitute the content
                    self.__set_element_data_content_at_frames(element_type, uid, element_data, fis_new)

                # Set the pointers (but the pointers we have to update using the union)
                self.__set_element_data_pointers(element_type, uid, element_data, fis_union)
            elif isinstance(element_data, types.mesh):
                # This is only for mesh case that can have this static part
                # (because it is an object data type which is both static and dynamic)
                self.__set_element_data_content(element_type, element, element_data)

    def __set_element_data_content_at_frames(self, element_type, uid, element_data, frame_intervals):
        # Loop over the specified frame_intervals to create or substitute the content
        # Create entries of the element_data at frames
        fis = frame_intervals.get()
        for fi in fis:
            for f in range(fi[0], fi[1] + 1):
                # Add element_data entry
                frame = self.get_frame(f)
                if frame is None:
                    self.__add_frame(f)
                    frame = self.get_frame(f)

                frame.setdefault(element_type.name + &#39;s&#39;, {})
                frame[element_type.name + &#39;s&#39;].setdefault(uid.as_str(), {})
                element = frame[element_type.name + &#39;s&#39;][uid.as_str()]
                self.__set_element_data_content(element_type, element, element_data)

    @staticmethod
    def __set_element_data_content(element_type, element, element_data):
        # Adds the element_data to the corresponding container
        # If an element_data with same name exists, it is substituted
        element.setdefault(element_type.name + &#39;_data&#39;, {})
        element[element_type.name + &#39;_data&#39;].setdefault(element_data.type.name, [])
        # Find if element_data already there
        list_aux = element[element_type.name + &#39;_data&#39;][element_data.type.name]
        pos_list = [idx for idx, val in enumerate(list_aux) if val[&#39;name&#39;] == element_data.data[&#39;name&#39;]]

        if len(pos_list) == 0:
            # Not found, then just push this new element data
            element[element_type.name + &#39;_data&#39;][element_data.type.name].append(element_data.data)
        else:
            # Found: let&#39;s substitute
            pos = pos_list[0]
            element[element_type.name + &#39;_data&#39;][element_data.type.name][pos] = element_data.data

    def __set_element_data_pointers(self, element_type, uid, element_data, frame_intervals):
        assert(isinstance(uid, UID))
        self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;][uid.as_str()].setdefault(element_type.name + &#39;_data_pointers&#39;, {})
        edp = self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;][uid.as_str()][element_type.name + &#39;_data_pointers&#39;]
        edp[element_data.data[&#39;name&#39;]] = {}
        edp[element_data.data[&#39;name&#39;]][&#39;type&#39;] = element_data.type.name
        if frame_intervals is None:
            edp[element_data.data[&#39;name&#39;]][&#39;frame_intervals&#39;] = []
        else:
            edp[element_data.data[&#39;name&#39;]][&#39;frame_intervals&#39;] = frame_intervals.get_dict()
        if &#39;attributes&#39; in element_data.data:
            edp[element_data.data[&#39;name&#39;]][&#39;attributes&#39;] = {}
            for attr_type in element_data.data[&#39;attributes&#39;]:  # attr_type might be &#39;boolean&#39;, &#39;text&#39;, &#39;num&#39;, or &#39;vec&#39;
                for attr in element_data.data[&#39;attributes&#39;][attr_type]:
                    edp[element_data.data[&#39;name&#39;]][&#39;attributes&#39;][attr[&#39;name&#39;]] = attr_type

    def __rm_frame(self, frame_num):
        # This function deletes a frame entry from frames, and updates VCD accordingly
        if &#39;frames&#39; in self.data[&#39;vcd&#39;]:
            if frame_num in self.data[&#39;vcd&#39;][&#39;frames&#39;]:
                del self.data[&#39;vcd&#39;][&#39;frames&#39;][frame_num]
            if len(self.data[&#39;vcd&#39;][&#39;frames&#39;]) == 0:
                del self.data[&#39;vcd&#39;][&#39;frames&#39;]

        # Remove from VCD frame intervals
        if &#39;frame_intervals&#39; in self.data[&#39;vcd&#39;]:
            fis_dict = self.data[&#39;vcd&#39;][&#39;frame_intervals&#39;]
            fis_dict_new = utils.rm_frame_from_frame_intervals(fis_dict, frame_num)

            # Now substitute
            if len(fis_dict_new) == 0:
                del self.data[&#39;vcd&#39;][&#39;frame_intervals&#39;]
            else:
                self.data[&#39;vcd&#39;][&#39;frame_intervals&#39;] = fis_dict_new


    def __compute_data_pointers(self):
        # WARNING! This function might be extremely slow
        # It does loop over all frames, and updates data pointers at objects, actions, etc
        # It is useful to convert from VCD 4.2.0 into VCD 4.3.0 (use converter.ConverterVCD420toVCD430)

        # Looping over frames and creating the necessary data_pointers
        if &#39;frame_intervals&#39; in self.data[&#39;vcd&#39;]:
            fis = self.data[&#39;vcd&#39;][&#39;frame_intervals&#39;]
            for fi in fis:
                for frame_num in range(fi[&#39;frame_start&#39;], fi[&#39;frame_end&#39;] + 1):
                    frame = self.get_frame(frame_num)
                    for element_type in ElementType:
                        if element_type.name + &#39;s&#39; in frame:  # e.g. &#34;objects&#34;, &#34;actions&#34;...
                            for uid, element in frame[element_type.name + &#39;s&#39;].items():
                                if element_type.name + &#39;_data&#39; in element:
                                    # So this element has element_data in this frame
                                    # and then we need to update the element_data_pointer at the root
                                    # we can safely assume it already exists

                                    # First, let&#39;s create a element_data_pointer at the root
                                    self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;][uid].\
                                        setdefault(element_type.name + &#39;_data_pointers&#39;, {})
                                    edp = self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;][uid]
                                    [element_type.name + &#39;_data_pointers&#39;]

                                    # Let&#39;s loop over the element_data
                                    for ed_type, ed_array in element[element_type.name + &#39;_data&#39;].items():
                                        # e.g. ed_type is &#39;bbox&#39;, ed_array is the array of such bboxes content
                                        for element_data in ed_array:
                                            name = element_data[&#39;name&#39;]
                                            edp.setdefault(name, {})  # this element_data may already exist
                                            edp[name].setdefault(&#39;type&#39;, ed_type)  # e.g. &#39;bbox&#39;
                                            edp[name].setdefault(&#39;frame_intervals&#39;, [])  # in case it does not exist
                                            fis_exist = FrameIntervals(edp[name][&#39;frame_intervals&#39;])
                                            fis_exist.union(FrameIntervals(frame_num))  # So, let&#39;s fuse with this frame
                                            edp[name][&#39;frame_intervals&#39;] = fis_exist.get_dict()  # overwrite
                                            # No need to manage attributes

    def rm_element_data_from_frames_by_name(self, element_type, uid, element_data_name, frame_intervals):
        for fi in frame_intervals.get():
            for f in range(fi[0], fi[1] + 1):
                if self.has_frame(f):
                    frame = self.data[&#39;vcd&#39;][&#39;frames&#39;][f]
                    if element_type.name + &#39;s&#39; in frame:
                        if uid.as_str() in frame[element_type.name + &#39;s&#39;]:
                            element = frame[element_type.name + &#39;s&#39;][uid.as_str()]
                            if element_type.name + &#39;_data&#39; in element:
                                # Delete only the element_data with the specified name
                                for prop in element[element_type.name + &#39;_data&#39;]:
                                    val_array = element[element_type.name + &#39;_data&#39;][prop]
                                    for i in range(0, len(val_array)):
                                        val = val_array[i]
                                        if val[&#39;name&#39;] == element_data_name:
                                            del element[element_type.name + &#39;_data&#39;][prop][i]

    def rm_element_data_from_frames(self, element_type, uid, frame_intervals):
        for fi in frame_intervals.get():
            for f in range(fi[0], fi[1] + 1):
                if self.has_frame(f):
                    frame = self.data[&#39;vcd&#39;][&#39;frames&#39;][f]
                    if element_type.name + &#39;s&#39; in frame:
                        if uid.as_str() in frame[element_type.name + &#39;s&#39;]:
                            element = frame[element_type.name + &#39;s&#39;][uid.as_str()]
                            if element_type.name + &#39;_data&#39; in element:
                                # Delete all its former dyamic element_data entries at old fis
                                del element[element_type.name + &#39;_data&#39;]

        # Clean-up data pointers of object_data that no longer exist!
        # Note, element_data_pointers are correctly updated, but there might be some now declared as static
        # corresponding to element_data that was dynamic but now has been removed when the element changed to static
        if self.has(element_type, uid.as_str()):
            element = self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;][uid.as_str()]
            if element_type.name + &#39;_data_pointers&#39; in element:
                edps = element[element_type.name + &#39;_data_pointers&#39;]
                edp_names_to_delete = []
                for edp_name in edps:
                    fis_ed = FrameIntervals(edps[edp_name][&#39;frame_intervals&#39;])
                    if fis_ed.empty():
                        # Check if element_data exists
                        ed_type = edps[edp_name][&#39;type&#39;]
                        found = False
                        if element_type.name + &#39;_data&#39; in element:
                            if ed_type in element[element_type.name + &#39;_data&#39;]:
                                for ed in element[element_type.name + &#39;_data&#39;][ed_type]:
                                    if ed[&#39;name&#39;] == edp_name:
                                        found = True
                                        break
                        if not found:
                            edp_names_to_delete.append(edp_name)
                for edp_name in edp_names_to_delete:
                    del element[element_type.name + &#39;_data_pointers&#39;][edp_name]

    ##################################################
    # Public API: add, update
    ##################################################
    def add_file_version(self, version):
        assert (type(version) is str)
        if &#39;metadata&#39; not in self.data[&#39;vcd&#39;]:
            self.data[&#39;vcd&#39;][&#39;metadata&#39;] = {}
        self.data[&#39;vcd&#39;][&#39;metadata&#39;][&#39;file_version&#39;] = version

    def add_metadata_properties(self, properties):
        assert(isinstance(properties, dict))
        prop = self.data[&#39;vcd&#39;][&#39;metadata&#39;]
        prop.update(properties)

    def add_name(self, name):
        assert(type(name) is str)
        if &#39;metadata&#39; not in self.data[&#39;vcd&#39;]:
            self.data[&#39;vcd&#39;][&#39;metadata&#39;] = {}
        self.data[&#39;vcd&#39;][&#39;metadata&#39;][&#39;name&#39;] = name

    def add_annotator(self, annotator):
        assert(type(annotator) is str)
        if &#39;metadata&#39; not in self.data[&#39;vcd&#39;]:
            self.data[&#39;vcd&#39;][&#39;metadata&#39;] = {}
        self.data[&#39;vcd&#39;][&#39;metadata&#39;][&#39;annotator&#39;] = annotator

    def add_comment(self, comment):
        assert(type(comment) is str)
        if &#39;metadata&#39; not in self.data[&#39;vcd&#39;]:
            self.data[&#39;vcd&#39;][&#39;metadata&#39;] = {}
        self.data[&#39;vcd&#39;][&#39;metadata&#39;][&#39;comment&#39;] = comment

    def add_ontology(self, ontology_name):
        self.data[&#39;vcd&#39;].setdefault(&#39;ontologies&#39;, dict())
        for ont_uid in self.data[&#39;vcd&#39;][&#39;ontologies&#39;]:
            if self.data[&#39;vcd&#39;][&#39;ontologies&#39;][ont_uid] == ontology_name:
                warnings.warn(&#39;WARNING: adding an already existing ontology&#39;)
                return None
        length = len(self.data[&#39;vcd&#39;][&#39;ontologies&#39;])
        self.data[&#39;vcd&#39;][&#39;ontologies&#39;][str(length)] = ontology_name
        return str(length)

    def add_coordinate_system(self, name, cs_type, parent_name=&#34;&#34;, pose_wrt_parent=[], uid=None):
        assert(isinstance(cs_type, types.CoordinateSystemType))
        # Create entry
        self.data[&#39;vcd&#39;].setdefault(&#39;coordinate_systems&#39;, {})
        self.data[&#39;vcd&#39;][&#39;coordinate_systems&#39;][name] = {&#39;type&#39;: cs_type.name,
                                                        &#39;parent&#39;: parent_name,
                                                        &#39;pose_wrt_parent&#39;: pose_wrt_parent,
                                                        &#39;children&#39;: []}
        if uid is not None:
            assert(isinstance(uid, str))
            self.data[&#39;vcd&#39;][&#39;coordinate_systems&#39;][name].update({&#34;uid&#34;: uid})

        # Update parents
        if parent_name != &#34;&#34;:
            found = False
            for n, cs in self.data[&#39;vcd&#39;][&#39;coordinate_systems&#39;].items():
                if n == parent_name:
                    found = True
                    cs[&#39;children&#39;].append(name)
            if not found:
                warnings.warn(&#34;WARNING: Creating a coordinate system with a non-defined parent coordinate system.&#34;
                              &#34;Coordinate systems must be introduced in order&#34;)

    def add_transform(self, frame_num, transform):
        assert (isinstance(frame_num, int))
        assert(isinstance(transform, types.Transform))

        self.__add_frame(frame_num)  # this function internally checks if the frame already exists
        self.data[&#39;vcd&#39;][&#39;frames&#39;][frame_num].setdefault(&#39;frame_properties&#39;, dict())
        self.data[&#39;vcd&#39;][&#39;frames&#39;][frame_num][&#39;frame_properties&#39;].setdefault(&#39;transforms&#39;, dict())
        self.data[&#39;vcd&#39;][&#39;frames&#39;][frame_num][&#39;frame_properties&#39;][&#39;transforms&#39;].update(transform.data)

    def add_stream(self, stream_name, uri, description, stream_type):
        assert(isinstance(stream_name, str))
        assert(isinstance(uri, str))
        assert(isinstance(description, str))

        self.data[&#39;vcd&#39;].setdefault(&#39;streams&#39;, dict())
        self.data[&#39;vcd&#39;][&#39;streams&#39;].setdefault(stream_name, dict())
        if isinstance(stream_type, StreamType):
            self.data[&#39;vcd&#39;][&#39;streams&#39;][stream_name] = {
                &#39;description&#39;: description, &#39;uri&#39;: uri, &#39;type&#39;: stream_type.name
            }
        elif isinstance(stream_type, str):
            self.data[&#39;vcd&#39;][&#39;streams&#39;][stream_name] = {
                &#39;description&#39;: description, &#39;uri&#39;: uri, &#39;type&#39;: stream_type
            }

    def add_frame_properties(self, frame_num, timestamp=None, properties=None):
        self.__add_frame(frame_num)  # this function internally checks if the frame already exists
        self.data[&#39;vcd&#39;][&#39;frames&#39;][frame_num].setdefault(&#39;frame_properties&#39;, dict())
        if timestamp is not None:
            assert (isinstance(timestamp, str))
            self.data[&#39;vcd&#39;][&#39;frames&#39;][frame_num][&#39;frame_properties&#39;][&#39;timestamp&#39;] = timestamp

        if properties is not None:
            assert (isinstance(properties, dict))
            self.data[&#39;vcd&#39;][&#39;frames&#39;][frame_num][&#39;frame_properties&#39;].update(properties)

    def add_stream_properties(self, stream_name, properties=None, intrinsics=None, stream_sync=None):
        has_arguments = False
        if intrinsics is not None:
            assert(isinstance(intrinsics, types.Intrinsics))
            has_arguments = True
        if properties is not None:
            assert(isinstance(properties, dict))  # &#34;Properties of Stream should be defined as a dictionary&#34;
            has_arguments = True
        if stream_sync is not None:
            assert(isinstance(stream_sync, types.StreamSync))
            has_arguments = True
            if stream_sync.frame_vcd is not None:
                frame_num = stream_sync.frame_vcd
            else:
                frame_num = None
        else:
            frame_num = None

        if not has_arguments:
            return

        # This function can be used to add stream properties. If frame_num is defined, the information is embedded
        # inside &#39;frame_properties&#39; of the specified frame. Otherwise, the information is embedded into
        # &#39;stream_properties&#39; inside &#39;metadata&#39;.

        # Find if this stream is declared
        if &#39;metadata&#39; in self.data[&#39;vcd&#39;]:
            if &#39;streams&#39; in self.data[&#39;vcd&#39;]:
                if stream_name in self.data[&#39;vcd&#39;][&#39;streams&#39;]:
                    if frame_num is None:
                        # This information is static
                        self.data[&#39;vcd&#39;][&#39;streams&#39;][stream_name].setdefault(&#39;stream_properties&#39;, dict())
                        if properties is not None:
                            self.data[&#39;vcd&#39;][&#39;streams&#39;][stream_name][&#39;stream_properties&#39;].\
                                update(properties)
                        if intrinsics is not None:
                            self.data[&#39;vcd&#39;][&#39;streams&#39;][stream_name][&#39;stream_properties&#39;].\
                                update(intrinsics.data)
                        if stream_sync is not None:
                            if stream_sync.data:
                                self.data[&#39;vcd&#39;][&#39;streams&#39;][stream_name][&#39;stream_properties&#39;].\
                                    update(stream_sync.data)
                    else:
                        # This is information of the stream for a specific frame
                        self.__add_frame(frame_num)  # to add the frame in case it does not exist
                        frame = self.data[&#39;vcd&#39;][&#39;frames&#39;][frame_num]
                        frame.setdefault(&#39;frame_properties&#39;, dict())
                        frame[&#39;frame_properties&#39;].setdefault(&#39;streams&#39;, dict())
                        frame[&#39;frame_properties&#39;][&#39;streams&#39;].setdefault(stream_name, dict())
                        frame[&#39;frame_properties&#39;][&#39;streams&#39;][stream_name].setdefault(&#39;stream_properties&#39;, dict())
                        if properties is not None:
                            frame[&#39;frame_properties&#39;][&#39;streams&#39;][stream_name][&#39;stream_properties&#39;].\
                                update(properties)
                        if intrinsics is not None:
                            frame[&#39;frame_properties&#39;][&#39;streams&#39;][stream_name][&#39;stream_properties&#39;].\
                                update(intrinsics.data)

                        if stream_sync.data:
                            frame[&#39;frame_properties&#39;][&#39;streams&#39;][stream_name][&#39;stream_properties&#39;].\
                                update(stream_sync.data)
                else:
                    warnings.warn(&#39;WARNING: Trying to add stream properties for non-existing stream. &#39;
                                  &#39;Use add_stream first.&#39;)

    def save_frame(self, frame_num, file_name, dynamic_only=True, pretty=False):
        string = self.stringify_frame(frame_num, dynamic_only, pretty)
        file = open(file_name, &#39;w&#39;)
        file.write(string)
        file.close()

    def save(self, file_name, pretty=False, validate=False):
        string = self.stringify(pretty, validate)
        file = open(file_name, &#39;w&#39;)
        file.write(string)
        file.close()

    def validate(self, stringified_vcd):
        temp = json.loads(stringified_vcd)
        if not hasattr(self, &#39;schema&#39;):
            self.schema = schema.vcd_schema
        validate(instance=temp, schema=self.schema)

    def stringify(self, pretty=True, validate=True):
        if pretty:
            stringified_vcd = json.dumps(self.data, indent=4, sort_keys=False)

        else:
            stringified_vcd = json.dumps(self.data, separators=(&#39;,&#39;, &#39;:&#39;), sort_keys=False)
        if validate:
            self.validate(stringified_vcd)
        return stringified_vcd

    def stringify_frame(self, frame_num, dynamic_only=True, pretty=False):
        if frame_num not in self.data[&#39;vcd&#39;][&#39;frames&#39;]:
            warnings.warn(&#34;WARNING: Trying to stringify a non-existing frame.&#34;)
            return &#39;&#39;

        if dynamic_only:
            if pretty:
                return json.dumps(self.data[&#39;vcd&#39;][&#39;frames&#39;][frame_num], indent=4, sort_keys=True)
            else:
                return json.dumps(self.data[&#39;vcd&#39;][&#39;frames&#39;][frame_num])

        else:
            # Need to compose dynamic and static information into a new structure
            # Copy the dynamic info first
            frame_static_dynamic = copy.deepcopy(self.data[&#39;vcd&#39;][&#39;frames&#39;][frame_num])  # Needs to be a copy!

            # Now the static info for objects, actions, events, contexts and relations
            # Relations can be frame-less or frame-specific
            for element_type in ElementType:
                # First, elements explicitly defined for this frame
                if element_type.name + &#39;s&#39; in self.data[&#39;vcd&#39;][&#39;frames&#39;][frame_num]:
                    for uid, content in self.data[&#39;vcd&#39;][&#39;frames&#39;][frame_num][element_type.name + &#39;s&#39;].items():
                        frame_static_dynamic[element_type.name + &#39;s&#39;][uid].update(
                            self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;][uid]
                        )
                        # Remove frameInterval entry
                        if &#39;frame_intervals&#39; in frame_static_dynamic[element_type.name + &#39;s&#39;][uid]:
                            del frame_static_dynamic[element_type.name + &#39;s&#39;][uid][&#39;frame_intervals&#39;]

                # But also other elements without frame intervals specified, which are assumed to exist during
                # the entire sequence, except frame-less Relations which are assumed to not be associated to any frame
                if element_type.name + &#39;s&#39; in self.data[&#39;vcd&#39;] and element_type.name != &#39;relation&#39;:
                    for uid, element in self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;].items():
                        frame_intervals_dict = element.get(&#39;frame_intervals&#39;)
                        if frame_intervals_dict is None or not frame_intervals_dict:
                            # So the list of frame intervals is empty -&gt; this element lives the entire scene
                            # Let&#39;s add it to frame_static_dynamic
                            frame_static_dynamic.setdefault(element_type.name + &#39;s&#39;, dict()) # in case there are no
                                                                        # such type of elements already in this frame
                            frame_static_dynamic[element_type.name + &#39;s&#39;][uid] = dict()
                            frame_static_dynamic[element_type.name + &#39;s&#39;][uid] = copy.deepcopy(element)

                            # Remove frameInterval entry
                            if &#39;frame_intervals&#39; in frame_static_dynamic[element_type.name + &#39;s&#39;][uid]:
                                del frame_static_dynamic[element_type.name + &#39;s&#39;][uid][&#39;frame_intervals&#39;]

            if pretty:
                return json.dumps(frame_static_dynamic, indent=4, sort_keys=True)
            else:
                return json.dumps(frame_static_dynamic)

    def add_object(self, name, semantic_type=&#39;&#39;, frame_value=None, uid=None, ont_uid=None, coordinate_system=None,
                   set_mode=SetMode.union):
        return self.__set_element(ElementType.object, name, semantic_type, FrameIntervals(frame_value),
                                  UID(uid), UID(ont_uid), coordinate_system, set_mode).as_str()

    def add_action(self, name, semantic_type=&#39;&#39;, frame_value=None, uid=None, ont_uid=None, coordinate_system=None,
                   set_mode=SetMode.union):
        return self.__set_element(ElementType.action, name, semantic_type, FrameIntervals(frame_value),
                                  UID(uid), UID(ont_uid), coordinate_system, set_mode).as_str()

    def add_event(self, name, semantic_type=&#39;&#39;, frame_value=None, uid=None, ont_uid=None, coordinate_system=None,
                  set_mode=SetMode.union):
        return self.__set_element(ElementType.event, name, semantic_type, FrameIntervals(frame_value),
                                  UID(uid), UID(ont_uid), coordinate_system, set_mode).as_str()

    def add_context(self, name, semantic_type=&#39;&#39;, frame_value=None, uid=None, ont_uid=None, coordinate_system=None,
                    set_mode=SetMode.union):
        return self.__set_element(ElementType.context, name, semantic_type, FrameIntervals(frame_value),
                                  UID(uid), UID(ont_uid), coordinate_system, set_mode).as_str()

    def add_relation(self, name, semantic_type=&#39;&#39;, frame_value=None, uid=None, ont_uid=None,
                     set_mode=SetMode.union):
        if set_mode == SetMode.replace and uid is not None:
            if self.has(ElementType.relation, uid):
                relation = self.data[&#39;vcd&#39;][&#39;relations&#39;][UID(uid).as_str()]
                relation[&#39;rdf_subjects&#39;] = []
                relation[&#39;rdf_objects&#39;] = []

        relation_uid = self.__set_element(
            ElementType.relation, name, semantic_type, frame_intervals=FrameIntervals(frame_value),
            uid=UID(uid), ont_uid=UID(ont_uid), set_mode=set_mode, coordinate_system=None)
        return relation_uid.as_str()

    def add_element(self, element_type, name, semantic_type=&#39;&#39;, frame_value=None, uid=None, ont_uid=None, coordinate_system=None,
                    set_mode=SetMode.union):
        return self.__set_element(element_type, name, semantic_type, FrameIntervals(frame_value),
                                  UID(uid), UID(ont_uid), coordinate_system, set_mode).as_str()

    def add_rdf(self, relation_uid, rdf_type, element_uid, element_type):
        assert(isinstance(element_type, ElementType))
        assert(isinstance(rdf_type, RDF))
        rel_uid = UID(relation_uid)
        el_uid = UID(element_uid)
        if rel_uid.as_str() not in self.data[&#39;vcd&#39;][&#39;relations&#39;]:
            warnings.warn(&#34;WARNING: trying to add RDF to non-existing Relation.&#34;)
            return
        else:
            relation = self.data[&#39;vcd&#39;][&#39;relations&#39;][rel_uid.as_str()]
            if el_uid.as_str() not in self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;]:
                warnings.warn(&#34;WARNING: trying to add RDF using non-existing Element.&#34;)
                return
            else:
                if rdf_type == RDF.subject:
                    relation.setdefault(&#39;rdf_subjects&#39;, [])
                    relation[&#39;rdf_subjects&#39;].append(
                        {&#39;uid&#39;: el_uid.as_str(), &#39;type&#39;: element_type.name}
                    )
                else:
                    relation.setdefault(&#39;rdf_objects&#39;, [])
                    relation[&#39;rdf_objects&#39;].append(
                        {&#39;uid&#39;: el_uid.as_str(), &#39;type&#39;: element_type.name}
                    )

    def add_relation_object_action(self, name, semantic_type, object_uid, action_uid, relation_uid=None,
                                   ont_uid=None, frame_value=None, set_mode=SetMode.union):
        # Note: no need to wrap uids as UID, since all calls are public functions, and no access to dict is done.
        relation_uid = self.add_relation(name, semantic_type, uid=relation_uid, ont_uid=ont_uid,
                                         frame_value=frame_value, set_mode=set_mode)
        self.add_rdf(relation_uid=relation_uid, rdf_type=RDF.subject,
                     element_uid=object_uid, element_type=ElementType.object)
        self.add_rdf(relation_uid=relation_uid, rdf_type=RDF.object,
                     element_uid=action_uid, element_type=ElementType.action)

        return relation_uid

    def add_relation_action_action(self, name, semantic_type, action_uid_1, action_uid_2, relation_uid=None,
                                   ont_uid=None, frame_value=None, set_mode=SetMode.union):
        # Note: no need to wrap uids as UID, since all calls are public functions, and no access to dict is done.
        relation_uid = self.add_relation(name, semantic_type, uid=relation_uid, ont_uid=ont_uid,
                                         frame_value=frame_value, set_mode=set_mode)
        self.add_rdf(relation_uid=relation_uid, rdf_type=RDF.subject,
                     element_uid=action_uid_1, element_type=ElementType.action)
        self.add_rdf(relation_uid=relation_uid, rdf_type=RDF.object,
                     element_uid=action_uid_2, element_type=ElementType.action)

        return relation_uid

    def add_relation_object_object(self, name, semantic_type, object_uid_1, object_uid_2, relation_uid=None,
                                   ont_uid=None, frame_value=None, set_mode=SetMode.union):
        # Note: no need to wrap uids as UID, since all calls are public functions, and no access to dict is done.
        relation_uid = self.add_relation(name, semantic_type, uid=relation_uid, ont_uid=ont_uid,
                                         frame_value=frame_value, set_mode=set_mode)
        self.add_rdf(relation_uid=relation_uid, rdf_type=RDF.subject,
                     element_uid=object_uid_1, element_type=ElementType.object)
        self.add_rdf(relation_uid=relation_uid, rdf_type=RDF.object,
                     element_uid=object_uid_2, element_type=ElementType.object)

        return relation_uid

    def add_relation_action_object(self, name, semantic_type, action_uid, object_uid, relation_uid=None,
                                   ont_uid=None, frame_value=None, set_mode=SetMode.union):
        # Note: no need to wrap uids as UID, since all calls are public functions, and no access to dict is done.
        relation_uid = self.add_relation(name, semantic_type, uid=relation_uid, ont_uid=ont_uid,
                                         frame_value=frame_value, set_mode=set_mode)
        self.add_rdf(relation_uid=relation_uid, rdf_type=RDF.subject,
                     element_uid=action_uid, element_type=ElementType.action)
        self.add_rdf(relation_uid=relation_uid, rdf_type=RDF.object,
                     element_uid=object_uid, element_type=ElementType.object)

        return relation_uid

    def add_relation_subject_object(self, name, semantic_type, subject_type, subject_uid, object_type, object_uid,
                                    relation_uid=None, ont_uid=None, frame_value=None, set_mode=SetMode.union):
        # Note: no need to wrap uids as UID, since all calls are public functions, and no access to dict is done.
        relation_uid = self.add_relation(name, semantic_type, uid=relation_uid, ont_uid=ont_uid,
                                         frame_value=frame_value, set_mode=set_mode)
        assert(isinstance(subject_type, ElementType))
        assert(isinstance(object_type, ElementType))
        self.add_rdf(relation_uid=relation_uid, rdf_type=RDF.subject,
                     element_uid=subject_uid, element_type=subject_type)
        self.add_rdf(relation_uid=relation_uid, rdf_type=RDF.object,
                     element_uid=object_uid, element_type=object_type)

        return relation_uid

    def add_object_data(self, uid, object_data, frame_value=None, set_mode=SetMode.union):
        return self.__set_element_data(ElementType.object, UID(uid), object_data, FrameIntervals(frame_value),
                                       set_mode)

    def add_action_data(self, uid, action_data, frame_value=None, set_mode=SetMode.union):
        return self.__set_element_data(ElementType.action, UID(uid), action_data, FrameIntervals(frame_value),
                                       set_mode)

    def add_event_data(self, uid, event_data, frame_value=None, set_mode=SetMode.union):
        return self.__set_element_data(ElementType.evevt, UID(uid), event_data, FrameIntervals(frame_value),
                                       set_mode)

    def add_context_data(self, uid, context_data, frame_value=None, set_mode=SetMode.union):
        return self.__set_element_data(ElementType.context, UID(uid), context_data, FrameIntervals(frame_value),
                                       set_mode)
    
    def add_element_data(self, element_type, uid, element_data, frame_value=None, set_mode=SetMode.union):
        return self.__set_element_data(element_type, UID(uid), element_data, FrameIntervals(frame_value),
                                       set_mode)

    ##################################################
    # Get / Read
    ##################################################
    def get_data(self):
        return self.data

    def has_elements(self, element_type):
        element_type_name = element_type.name
        return element_type_name + &#39;s&#39; in self.data[&#39;vcd&#39;]

    def has_objects(self):
        return &#39;objects&#39; in self.data[&#39;vcd&#39;]

    def has_actions(self):
        return &#39;actions&#39; in self.data[&#39;vcd&#39;]

    def has_contexts(self):
        return &#39;contexts&#39; in self.data[&#39;vcd&#39;]

    def has_events(self):
        return &#39;events&#39; in self.data[&#39;vcd&#39;]

    def has_relations(self):
        return &#39;relations&#39; in self.data[&#39;vcd&#39;]

    def has(self, element_type, uid):
        if not element_type.name + &#39;s&#39; in self.data[&#39;vcd&#39;]:
            return False
        else:
            uid_str = UID(uid).as_str()
            if uid_str in self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;]:
                return True
            else:
                return False

    def has_element_data(self, element_type, uid, element_data):
        if not self.has(element_type, uid):
            return False
        else:
            uid_str = UID(uid).as_str()
            if element_type.name + &#39;_data_pointers&#39; not in self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;][uid_str]:
                return False
            name = element_data.data[&#39;name&#39;]
            return name in self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;][uid_str][element_type.name + &#39;_data_pointers&#39;]

    def has_frame(self, frame_num):
        if &#39;frames&#39; not in self.data[&#39;vcd&#39;]:
            return False
        else:
            if frame_num in self.data[&#39;vcd&#39;][&#39;frames&#39;]:
                return True
            else:
                return False

    def get_all(self, element_type):
        &#34;&#34;&#34;
        Returns all elements of the specified ElementType.
        e.g. all Object&#39;s or Context&#39;s
        &#34;&#34;&#34;
        assert(isinstance(element_type, ElementType))
        return self.data[&#39;vcd&#39;].get(element_type.name + &#39;s&#39;)

    def get_element(self, element_type, uid):
        assert (isinstance(element_type, ElementType))
        if self.data[&#39;vcd&#39;].get(element_type.name + &#39;s&#39;) is None:
            warnings.warn(&#34;WARNING: trying to get a &#34; + element_type.name + &#34; but this VCD has none.&#34;)
            return None
        uid_str = UID(uid).as_str()
        if uid_str in self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;]:
            return self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;][uid_str]
        else:
            warnings.warn(&#34;WARNING: trying to get non-existing &#34; + element_type.name + &#34; with uid: &#34; + uid_str)
            return None

    def get_object(self, uid):
        return self.get_element(ElementType.object, uid)

    def get_action(self, uid):
        return self.get_element(ElementType.action, uid)

    def get_event(self, uid):
        return self.get_element(ElementType.event, uid)

    def get_context(self, uid):
        return self.get_element(ElementType.context, uid)

    def get_relation(self, uid):
        return self.get_element(ElementType.relation, uid)

    def get_element_uid_by_name(self, element_type, name):
        assert (self.has_elements(element_type))
        element_type_name = element_type.name
        elements = self.data[&#39;vcd&#39;][element_type_name + &#39;s&#39;]
        for uid, element in elements.items():
            name_element = element[&#39;name&#39;]
            if name_element == name:
                return uid
        return None

    def get_object_uid_by_name(self, name):
        return self.get_element_uid_by_name(ElementType.object, name)

    def get_action_uid_by_name(self, name):
        return self.get_element_uid_by_name(ElementType.action, name)

    def get_context_uid_by_name(self, name):
        return self.get_element_uid_by_name(ElementType.context, name)

    def get_event_uid_by_name(self, name):
        return self.get_element_uid_by_name(ElementType.event, name)

    def get_relation_uid_by_name(self, name):
        return self.get_element_uid_by_name(ElementType.relation, name)

    def get_frame(self, frame_num):
        if &#39;frames&#39; not in self.data[&#39;vcd&#39;]:
            return None
        else:
            frame = self.data[&#39;vcd&#39;][&#39;frames&#39;].get(frame_num)
            return frame

    def get_elements_of_type(self, element_type, semantic_type):
        uids_str = []
        if not element_type.name + &#39;s&#39; in self.data[&#39;vcd&#39;]:
            return uids_str
        for uid_str, element in self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;].items():
            if element[&#39;type&#39;] == semantic_type:
                uids_str.append(uid_str)
        return uids_str

    def get_elements_with_element_data_name(self, element_type, data_name):
        uids_str = []
        for uid_str in self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;]:
            element = self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;][uid_str]
            if element_type.name + &#39;_data_pointers&#39; in element:
                for name in element[element_type.name + &#39;_data_pointers&#39;]:
                    if name == data_name:
                        uids_str.append(uid_str)
                        break
        return uids_str

    def get_objects_with_object_data_name(self, data_name):
        return self.get_elements_with_element_data_name(ElementType.object, data_name)

    def get_actions_with_action_data_name(self, data_name):
        return self.get_elements_with_element_data_name(ElementType.action, data_name)

    def get_events_with_event_data_name(self, data_name):
        return self.get_elements_with_element_data_name(ElementType.event, data_name)

    def get_contexts_with_context_data_name(self, data_name):
        return self.get_elements_with_element_data_name(ElementType.context, data_name)

    def get_frames_with_element_data_name(self, element_type, uid, data_name):
        uid_str = UID(uid).as_str()
        if uid_str in self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;]:
            element = self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;][uid_str]
            if element_type.name + &#39;_data_pointers&#39; in element:
                for name in element[element_type.name + &#39;_data_pointers&#39;]:
                    if name == data_name:
                        return FrameIntervals(element[element_type.name + &#39;_data_pointers&#39;][name][&#39;frame_intervals&#39;])
        return None

    def get_frames_with_object_data_name(self, uid, data_name):
        return self.get_frames_with_element_data_name(ElementType.object, uid, data_name)

    def get_frames_with_action_data_name(self, uid, data_name):
        return self.get_frames_with_element_data_name(ElementType.action, uid, data_name)

    def get_frames_with_event_data_name(self, uid, data_name):
        return self.get_frames_with_element_data_name(ElementType.event, uid, data_name)

    def get_frames_with_context_data_name(self, uid, data_name):
        return self.get_frames_with_element_data_name(ElementType.context, uid, data_name)

    def get_element_data_count_per_type(self, element_type, uid, data_type, frame_num=None):
        # Returns 0 if no such element exist or if the element does not have the data_type
        # Returns the count otherwise (e.g. how many &#34;bbox&#34; does this object have)
        assert(isinstance(data_type, types.ObjectDataType))
        uid_str = UID(uid).as_str()
        if self.has(element_type, uid):
            if frame_num is not None:
                # Dynamic info
                if not isinstance(frame_num, int):
                    warnings.warn(&#34;WARNING: Calling get_element_data with a non-integer frame_num.&#34;)
                frame = self.get_frame(frame_num)
                if frame is not None:
                    if element_type.name + &#39;s&#39; in frame:
                        if uid_str in frame[element_type.name + &#39;s&#39;]:
                            element = frame[element_type.name + &#39;s&#39;][uid_str]
                            for prop in element[element_type.name + &#39;_data&#39;]:
                                if prop == data_type.name:
                                    return len(element[element_type.name + &#39;_data&#39;][prop])
                        else:
                            return 0
                    else:
                        return 0
            else:
                # Static info
                element = self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;][uid_str]
                for prop in element[element_type.name + &#39;_data&#39;]:
                    if prop == data_type.name:
                        return len(element[element_type.name + &#39;_data&#39;][prop])
        else:
            return 0
        return 0

    def get_element_data(self, element_type, uid, data_name, frame_num=None):
        element_exists = self.has(element_type, uid)
        vcd_has_frames = not self.get_frame_intervals().empty()

        if not element_exists:  # the element does not exist
            return None

        if not vcd_has_frames and frame_num is not None:  # don&#39;t ask for frame-specific info in a VCD without frames
            return None

        frame_num_is_number = isinstance(frame_num, int)
        uid_str = UID(uid).as_str()

        element_exists_in_this_frame = False
        if frame_num is not None and frame_num_is_number:
            # The user is asking for frame-specific attributes

            found_in_frame = False
            frame = self.get_frame(frame_num)
            if frame is not None:
                if element_type.name + &#39;s&#39; in frame:
                    if uid_str in frame[element_type.name + &#39;s&#39;]:
                        element_exists_in_this_frame = True
                        element = frame[element_type.name + &#39;s&#39;][uid_str]
                        if element_type.name + &#39;_data&#39; in element:
                            for prop in element[element_type.name + &#39;_data&#39;]:
                                val_array = element[element_type.name + &#39;_data&#39;][prop]
                                for val in val_array:
                                    if val[&#39;name&#39;] == data_name:
                                        return val
            if not found_in_frame:
                # The user has asked to get an element_data for a certain frame, but there is no info about this
                # element or element_data at this frame
                if not element_exists_in_this_frame:
                    return None
                element = self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;][uid_str]  # the element exists because of prev. ctrl
                for prop in element[element_type.name + &#39;_data&#39;]:
                    val_array = element[element_type.name + &#39;_data&#39;][prop]
                    for val in val_array:
                        if val[&#39;name&#39;] == data_name:
                            return val
        else:
            # The user is asking for static attributes at the root of the element
            element = self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;][uid_str]  # the element exists because of prev. ctrl
            for prop in element[element_type.name + &#39;_data&#39;]:
                val_array = element[element_type.name + &#39;_data&#39;][prop]
                for val in val_array:
                    if val[&#39;name&#39;] == data_name:
                        return val
        return None

    def get_object_data(self, uid, data_name, frame_num=None):
        return self.get_element_data(ElementType.object, uid, data_name, frame_num)

    def get_action_data(self, uid, data_name, frame_num=None):
        return self.get_element_data(ElementType.action, uid, data_name, frame_num)

    def get_event_data(self, uid, data_name, frame_num=None):
        return self.get_element_data(ElementType.event, uid, data_name, frame_num)

    def get_context_data(self, uid, data_name, frame_num=None):
        return self.get_element_data(ElementType.context, uid, data_name, frame_num)

    def get_element_data_pointer(self, element_type, uid, data_name):
        uid_str = UID(uid).as_str()
        if self.has(element_type, uid):
            if element_type.name + &#39;s&#39; in self.data[&#39;vcd&#39;]:
                if uid_str in self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;]:
                    element = self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;][uid_str]
                    if element_type.name + &#39;_data_pointers&#39; in element:
                        if data_name in element[element_type.name + &#39;_data_pointers&#39;]:
                            return element[element_type.name + &#39;_data_pointers&#39;][data_name]
        else:
            warnings.warn(&#34;WARNING: Asking element data from a non-existing Element.&#34;)
        return None

    def get_element_data_frame_intervals(self, element_type, uid, data_name):
        return FrameIntervals(self.get_element_data_pointer(element_type, uid, data_name)[&#39;frame_intervals&#39;])

    def get_object_data_frame_intervals(self, uid, data_name):
        return self.get_element_data_frame_intervals(ElementType.object, uid, data_name)

    def get_action_data_frame_intervals(self, uid, data_name):
        return self.get_element_data_frame_intervals(ElementType.action, uid, data_name)

    def get_event_data_frame_intervals(self, uid, data_name):
        return self.get_element_data_frame_intervals(ElementType.event, uid, data_name)

    def get_context_data_frame_intervals(self, uid, data_name):
        return self.get_element_data_frame_intervals(ElementType.context, uid, data_name)

    def get_num_elements(self, element_type):
        if self.has_elements(element_type):
            return len(self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;])
        else:
            return 0

    def get_num_objects(self):
        return self.get_num_elements(ElementType.object)

    def get_num_actions(self):
        return self.get_num_elements(ElementType.action)

    def get_num_events(self):
        return self.get_num_elements(ElementType.event)

    def get_num_contexts(self):
        return self.get_num_elements(ElementType.context)

    def get_num_relations(self):
        return self.get_num_elements(ElementType.relation)

    def get_elements_uids(self, element_type: ElementType):
        if self.has_elements(element_type):
            list_of_uids = list(self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;].keys())
            return list_of_uids
        else:
            return []

    def get_ontology(self, ont_uid):
        ont_uid_str = UID(ont_uid).as_str()
        if &#39;ontologies&#39; in self.data[&#39;vcd&#39;]:
            if ont_uid_str in self.data[&#39;vcd&#39;][&#39;ontologies&#39;]:
                return copy.deepcopy(self.data[&#39;vcd&#39;][&#39;ontologies&#39;][ont_uid_str])
        return None

    def get_metadata(self):
        if &#39;metadata&#39; in self.data[&#39;vcd&#39;]:
            return self.data[&#39;vcd&#39;][&#39;metadata&#39;]
        else:
            return dict()

    def has_coordinate_system(self, cs):
        if &#39;coordinate_systems&#39; in self.data[&#39;vcd&#39;]:
            if cs in self.data[&#39;vcd&#39;][&#39;coordinate_systems&#39;]:
                return True
        return False

    def get_coordinate_systems(self):
        if &#39;coordinate_systems&#39; in self.data[&#39;vcd&#39;]:
            return copy.deepcopy(self.data[&#39;vcd&#39;][&#39;coordinate_systems&#39;])
        else:
            return []

    def get_coordinate_system(self, coordinate_system):
        if self.has_coordinate_system(coordinate_system):
            return copy.deepcopy(self.data[&#39;vcd&#39;][&#39;coordinate_systems&#39;][coordinate_system])
        else:
            return None

    def has_stream(self, stream_name):
        if &#39;streams&#39; in self.data[&#39;vcd&#39;]:
            if stream_name in self.data[&#39;vcd&#39;][&#39;streams&#39;]:
                return True
            else:
                return False

    def get_streams(self):
        if &#39;streams&#39; in self.data[&#39;vcd&#39;]:
            return copy.deepcopy(self.data[&#39;vcd&#39;][&#39;streams&#39;])
        else:
            return {}

    def get_stream(self, stream_name):
        if self.has_stream(stream_name):
            return copy.deepcopy(self.data[&#39;vcd&#39;][&#39;streams&#39;][stream_name])
        else:
            return None

    def get_frame_intervals(self):
        if &#39;frame_intervals&#39; in self.data[&#39;vcd&#39;]:
            return FrameIntervals(self.data[&#39;vcd&#39;][&#39;frame_intervals&#39;])
        else:
            return FrameIntervals()

    def get_element_frame_intervals(self, element_type, uid):
        uid_str = UID(uid).as_str()
        if not element_type.name + &#39;s&#39; in self.data[&#39;vcd&#39;]:
            return FrameIntervals()
        else:
            if not uid_str in self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;]:
                return FrameIntervals()
            return FrameIntervals(self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;][uid_str].get(&#39;frame_intervals&#39;))

    def relation_has_frame_intervals(self, relation_uid):
        rel_uid = UID(relation_uid)
        relation = self.get_relation(relation_uid)
        if relation is None:
            warnings.warn(&#34;WARNING: Non-existing relation &#34; + rel_uid.as_str())
        else:
            if &#39;frame_intervals&#39; not in relation:
                return False
            else:
                if len(relation[&#39;frame_intervals&#39;]) == 0:
                    return False
                else:
                    return True

    ##################################################
    # Remove
    ##################################################
    def rm_element_by_type(self, element_type, semantic_type):
        elements = self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;]

        # Get Element from summary
        uids_to_remove_str = []
        for uid_str, element in elements.items():
            if element[&#39;type&#39;] == semantic_type:
                uids_to_remove_str.append(uid_str)
        for uid_str in uids_to_remove_str:
            self.rm_element(element_type, uid_str)

    def rm_object_by_type(self, semantic_type):
        self.rm_element_by_type(ElementType.object, semantic_type)

    def rm_action_by_type(self, semantic_type):
        self.rm_element_by_type(ElementType.action, semantic_type)

    def rm_event_by_type(self, semantic_type):
        self.rm_element_by_type(ElementType.event, semantic_type)

    def rm_context_by_type(self, semantic_type):
        self.rm_element_by_type(ElementType.context, semantic_type)

    def rm_relation_by_type(self, semantic_type):
        self.rm_element_by_type(ElementType.relation, semantic_type)

    def rm_element(self, element_type, uid):
        uid_str = UID(uid).as_str()
        if not self.has_elements(element_type):
            return

        # Get element from summary
        if not self.has(element_type, uid):
            return

        # Remove from frames: let&#39;s read frame_intervals from summary
        elements = self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;]
        element = elements[uid_str]
        if &#39;frame_intervals&#39; in element:
            for i in range(0, len(element[&#39;frame_intervals&#39;])):
                fi = element[&#39;frame_intervals&#39;][i]
                for frame_num in range(fi[&#39;frame_start&#39;], fi[&#39;frame_end&#39;]+1):
                    elements_in_frame = self.data[&#39;vcd&#39;][&#39;frames&#39;][frame_num][element_type.name + &#39;s&#39;]
                    if uid in elements_in_frame:
                        del elements_in_frame[uid_str]
                    if len(elements_in_frame) == 0:  # objects might have end up empty TODO: test this
                        del self.data[&#39;vcd&#39;][&#39;frames&#39;][frame_num][element_type.name + &#39;s&#39;]
                        if len(self.data[&#39;vcd&#39;][&#39;frames&#39;][frame_num]) == 0:  # this frame may have ended up being empty
                            del self.data[&#39;vcd&#39;][&#39;frames&#39;][frame_num]
                            self.__rm_frame(frame_num)

        # Delete this element from summary
        del elements[uid_str]
        if len(elements) == 0:
            del self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;]

    def rm_object(self, uid):
        self.rm_element(ElementType.object, uid)

    def rm_action(self, uid):
        self.rm_element(ElementType.action, uid)

    def rm_event(self, uid):
        self.rm_element(ElementType.event, uid)

    def rm_context(self, uid):
        self.rm_element(ElementType.context, uid)

    def rm_relation(self, uid):
        self.rm_element(ElementType.relation, uid)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="vcd.core.ElementType"><code class="flex name class">
<span>class <span class="ident">ElementType</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Elements of VCD (Object, Action, Event, Context, Relation)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ElementType(Enum):
    &#34;&#34;&#34;
    Elements of VCD (Object, Action, Event, Context, Relation)
    &#34;&#34;&#34;
    object = 1
    action = 2
    event = 3
    context = 4
    relation = 5</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="vcd.core.ElementType.action"><code class="name">var <span class="ident">action</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="vcd.core.ElementType.context"><code class="name">var <span class="ident">context</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="vcd.core.ElementType.event"><code class="name">var <span class="ident">event</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="vcd.core.ElementType.object"><code class="name">var <span class="ident">object</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="vcd.core.ElementType.relation"><code class="name">var <span class="ident">relation</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="vcd.core.FrameIntervals"><code class="flex name class">
<span>class <span class="ident">FrameIntervals</span></span>
<span>(</span><span>frame_value=None)</span>
</code></dt>
<dd>
<div class="desc"><p>FrameIntervals class aims to simplify management of frame intervals</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FrameIntervals:
    &#34;&#34;&#34;
    FrameIntervals class aims to simplify management of frame intervals
    &#34;&#34;&#34;
    def __init__(self, frame_value=None):
        self.fis_dict = []
        self.fis_num = []

        if frame_value is not None:
            if isinstance(frame_value, int):
                self.fis_dict = [{&#39;frame_start&#39;: frame_value, &#39;frame_end&#39;: frame_value}]
                self.fis_num = [(frame_value, frame_value)]
            elif isinstance(frame_value, list):
                if len(frame_value) == 0:
                    return
                if all(isinstance(x, tuple) for x in frame_value):
                    # Then, frame_value is an array of tuples
                    self.fis_dict = utils.as_frame_intervals_array_dict(frame_value)
                    self.fis_dict = utils.fuse_frame_intervals(self.fis_dict)
                    self.fis_num = utils.as_frame_intervals_array_tuples(self.fis_dict)
                elif all(isinstance(x, list) for x in frame_value):
                    # This is possibly a list of list, e.g. [[0, 10], [12, 15]], instead of the above case list of tupl
                    self.fis_dict = utils.as_frame_intervals_array_dict(frame_value)
                    self.fis_dict = utils.fuse_frame_intervals(self.fis_dict)
                    self.fis_num = utils.as_frame_intervals_array_tuples(self.fis_dict)
                elif all(isinstance(x, dict) for x in frame_value):
                    # User provided a list of dict
                    self.fis_dict = frame_value
                    self.fis_dict = utils.fuse_frame_intervals(self.fis_dict)
                    self.fis_num = utils.as_frame_intervals_array_tuples(self.fis_dict)
            elif isinstance(frame_value, tuple):
                # Then, frame_value is a tuple (one single frame interval)
                self.fis_num = [frame_value]
                self.fis_dict = utils.as_frame_intervals_array_dict(self.fis_num)
            elif isinstance(frame_value, dict):
                # User provided a single dict
                self.fis_dict = [frame_value]
                self.fis_num = utils.as_frame_intervals_array_tuples(self.fis_dict)
            else:
                warnings.warn(&#34;ERROR: Unsupported FrameInterval format.&#34;)

    def empty(self):
        if len(self.fis_dict) == 0 or len(self.fis_num) == 0:
            return True
        else:
            return False

    def get_dict(self):
        return self.fis_dict

    def get(self):
        return self.fis_num

    def get_length(self):
        length = 0
        for fi in self.fis_num:
            length += fi[1] + 1 - fi[0]
        return length

    def rm_frame(self, frame_num):
        self.fis_dict = utils.rm_frame_from_frame_intervals(self.fis_dict, frame_num)
        self.fis_num = utils.as_frame_intervals_array_tuples(self.fis_dict)

    def union(self, frame_intervals):
        fis_union = utils.fuse_frame_intervals(frame_intervals.get_dict() + self.fis_dict)
        return FrameIntervals(fis_union)

    def intersection(self, frame_intervals):
        fis_int = utils.intersection_between_frame_interval_arrays(self.fis_num, frame_intervals.get())
        return FrameIntervals(fis_int)

    def equals(self, frame_intervals):
        fis_int = self.intersection(frame_intervals)
        fis_union = self.union(frame_intervals)

        if fis_int.get_length() == fis_union.get_length():
            return True
        else:
            return False

    def contains(self, frame_intervals):
        fis_int = self.intersection(frame_intervals)

        if fis_int.get_length() == frame_intervals.get_length():
            return True
        else:
            return False

    def is_contained_by(self, frame_intervals):
        fis_int = self.intersection(frame_intervals)

        if fis_int.get_length() == self.get_length():
            return True
        else:
            return False

    def get_outer(self):
        return utils.get_outer_frame_interval(self.fis_dict)

    def has_frame(self, frame_num):
        return utils.is_inside_frame_intervals(frame_num, self.fis_num)

    def to_str(self):
        text = &#34;[&#34;
        for fi in self.fis_num:
            text += &#34;(&#34; + str(fi[0]) + &#34;,&#34; + str(fi[1]) + &#34;)&#34;
        text += &#34;]&#34;

        return text</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="vcd.core.FrameIntervals.contains"><code class="name flex">
<span>def <span class="ident">contains</span></span>(<span>self, frame_intervals)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def contains(self, frame_intervals):
    fis_int = self.intersection(frame_intervals)

    if fis_int.get_length() == frame_intervals.get_length():
        return True
    else:
        return False</code></pre>
</details>
</dd>
<dt id="vcd.core.FrameIntervals.empty"><code class="name flex">
<span>def <span class="ident">empty</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def empty(self):
    if len(self.fis_dict) == 0 or len(self.fis_num) == 0:
        return True
    else:
        return False</code></pre>
</details>
</dd>
<dt id="vcd.core.FrameIntervals.equals"><code class="name flex">
<span>def <span class="ident">equals</span></span>(<span>self, frame_intervals)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def equals(self, frame_intervals):
    fis_int = self.intersection(frame_intervals)
    fis_union = self.union(frame_intervals)

    if fis_int.get_length() == fis_union.get_length():
        return True
    else:
        return False</code></pre>
</details>
</dd>
<dt id="vcd.core.FrameIntervals.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self):
    return self.fis_num</code></pre>
</details>
</dd>
<dt id="vcd.core.FrameIntervals.get_dict"><code class="name flex">
<span>def <span class="ident">get_dict</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_dict(self):
    return self.fis_dict</code></pre>
</details>
</dd>
<dt id="vcd.core.FrameIntervals.get_length"><code class="name flex">
<span>def <span class="ident">get_length</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_length(self):
    length = 0
    for fi in self.fis_num:
        length += fi[1] + 1 - fi[0]
    return length</code></pre>
</details>
</dd>
<dt id="vcd.core.FrameIntervals.get_outer"><code class="name flex">
<span>def <span class="ident">get_outer</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_outer(self):
    return utils.get_outer_frame_interval(self.fis_dict)</code></pre>
</details>
</dd>
<dt id="vcd.core.FrameIntervals.has_frame"><code class="name flex">
<span>def <span class="ident">has_frame</span></span>(<span>self, frame_num)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_frame(self, frame_num):
    return utils.is_inside_frame_intervals(frame_num, self.fis_num)</code></pre>
</details>
</dd>
<dt id="vcd.core.FrameIntervals.intersection"><code class="name flex">
<span>def <span class="ident">intersection</span></span>(<span>self, frame_intervals)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def intersection(self, frame_intervals):
    fis_int = utils.intersection_between_frame_interval_arrays(self.fis_num, frame_intervals.get())
    return FrameIntervals(fis_int)</code></pre>
</details>
</dd>
<dt id="vcd.core.FrameIntervals.is_contained_by"><code class="name flex">
<span>def <span class="ident">is_contained_by</span></span>(<span>self, frame_intervals)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_contained_by(self, frame_intervals):
    fis_int = self.intersection(frame_intervals)

    if fis_int.get_length() == self.get_length():
        return True
    else:
        return False</code></pre>
</details>
</dd>
<dt id="vcd.core.FrameIntervals.rm_frame"><code class="name flex">
<span>def <span class="ident">rm_frame</span></span>(<span>self, frame_num)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rm_frame(self, frame_num):
    self.fis_dict = utils.rm_frame_from_frame_intervals(self.fis_dict, frame_num)
    self.fis_num = utils.as_frame_intervals_array_tuples(self.fis_dict)</code></pre>
</details>
</dd>
<dt id="vcd.core.FrameIntervals.to_str"><code class="name flex">
<span>def <span class="ident">to_str</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_str(self):
    text = &#34;[&#34;
    for fi in self.fis_num:
        text += &#34;(&#34; + str(fi[0]) + &#34;,&#34; + str(fi[1]) + &#34;)&#34;
    text += &#34;]&#34;

    return text</code></pre>
</details>
</dd>
<dt id="vcd.core.FrameIntervals.union"><code class="name flex">
<span>def <span class="ident">union</span></span>(<span>self, frame_intervals)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def union(self, frame_intervals):
    fis_union = utils.fuse_frame_intervals(frame_intervals.get_dict() + self.fis_dict)
    return FrameIntervals(fis_union)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="vcd.core.RDF"><code class="flex name class">
<span>class <span class="ident">RDF</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Type of RDF agent (subject or object)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RDF(Enum):
    &#34;&#34;&#34;
    Type of RDF agent (subject or object)
    &#34;&#34;&#34;
    subject = 1
    object = 2</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="vcd.core.RDF.object"><code class="name">var <span class="ident">object</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="vcd.core.RDF.subject"><code class="name">var <span class="ident">subject</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="vcd.core.SetMode"><code class="flex name class">
<span>class <span class="ident">SetMode</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>The SetMode specifies how added content is inserted.
SetMode.union is the default value,
and determines that any new call to add functions (e.g. add_object, or add_action_data),
actually adds content, extending the frame_intervals of the recipient container to the
limits defined by the newly provided frame_intervals, effectively extending it to the union
of frame_intervals (existing plus new), substituting the content which already existed
with coincident frame (and name, uid, etc).
SetMode.replace acts replacing old content by new, potentially removing frames if the newly
provided frame_intervals are shorter than the existing ones.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SetMode(Enum):
    &#34;&#34;&#34;
    The SetMode specifies how added content is inserted.
    SetMode.union is the default value,
    and determines that any new call to add functions (e.g. add_object, or add_action_data),
    actually adds content, extending the frame_intervals of the recipient container to the
    limits defined by the newly provided frame_intervals, effectively extending it to the union
    of frame_intervals (existing plus new), substituting the content which already existed
    with coincident frame (and name, uid, etc).
    SetMode.replace acts replacing old content by new, potentially removing frames if the newly
    provided frame_intervals are shorter than the existing ones.
    &#34;&#34;&#34;
    union = 1
    replace = 2</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="vcd.core.SetMode.replace"><code class="name">var <span class="ident">replace</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="vcd.core.SetMode.union"><code class="name">var <span class="ident">union</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="vcd.core.StreamType"><code class="flex name class">
<span>class <span class="ident">StreamType</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Type of stream (sensor).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StreamType(Enum):
    &#34;&#34;&#34;
    Type of stream (sensor).
    &#34;&#34;&#34;
    camera = 1
    lidar = 2
    radar = 3
    gps_imu = 4
    other = 5</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="vcd.core.StreamType.camera"><code class="name">var <span class="ident">camera</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="vcd.core.StreamType.gps_imu"><code class="name">var <span class="ident">gps_imu</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="vcd.core.StreamType.lidar"><code class="name">var <span class="ident">lidar</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="vcd.core.StreamType.other"><code class="name">var <span class="ident">other</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="vcd.core.StreamType.radar"><code class="name">var <span class="ident">radar</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="vcd.core.UID"><code class="flex name class">
<span>class <span class="ident">UID</span></span>
<span>(</span><span>val=None)</span>
</code></dt>
<dd>
<div class="desc"><p>This is a helper class that simplifies management of UIDs.
Public functions permits the user to introduce either int or string values as UIDs
Internal functions create the UID objects to ensure the proper format is used where needed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UID:
    &#34;&#34;&#34;
    This is a helper class that simplifies management of UIDs.
    Public functions permits the user to introduce either int or string values as UIDs
    Internal functions create the UID objects to ensure the proper format is used where needed
    &#34;&#34;&#34;
    def __init__(self, val=None):
        if val is None:
            # Void uid
            self.__set(&#34;&#34;, -1, False)
        else:
            if isinstance(val, int):
                self.__set(str(val), val, False)
            elif isinstance(val, str):
                if val == &#39;&#39;:
                    self.__set(&#34;&#34;, -1, False)
                else:
                    if val.strip(&#39;-&#39;).isnumeric():  # this holds true for &#34;-3&#34; and &#34;3&#34;
                        self.__set(val, int(val), False)
                    elif bool(re.match(r&#34;^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$&#34;,
                                       val)):
                        self.__set(val, -1, True)
                    else:
                        warnings.warn(&#34;ERROR: Unsupported UID string type.&#34;)
                        self.__set(&#34;&#34;, -1, False)
            else:
                warnings.warn(&#34;ERROR: Unsupported UID type.&#34;)
                self.__set(&#34;&#34;, -1, False)

    def __set(self, uid_str=None, uid_int=None, is_uuid=False):
        self.uid_str = uid_str
        self.uid_int = uid_int
        self.uuid = is_uuid

    def is_uuid(self):
        return self.uuid

    def as_str(self):
        return self.uid_str

    def as_int(self):
        if self.is_uuid():
            warnings.warn(&#34;ERROR: This UID is not numeric, can&#39;t call getAsInt.&#34;)
        else:
            return self.uid_int

    def is_none(self):
        if self.uid_int == -1 and self.uid_str == &#34;&#34;:
            return True
        else:
            return False</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="vcd.core.UID.as_int"><code class="name flex">
<span>def <span class="ident">as_int</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def as_int(self):
    if self.is_uuid():
        warnings.warn(&#34;ERROR: This UID is not numeric, can&#39;t call getAsInt.&#34;)
    else:
        return self.uid_int</code></pre>
</details>
</dd>
<dt id="vcd.core.UID.as_str"><code class="name flex">
<span>def <span class="ident">as_str</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def as_str(self):
    return self.uid_str</code></pre>
</details>
</dd>
<dt id="vcd.core.UID.is_none"><code class="name flex">
<span>def <span class="ident">is_none</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_none(self):
    if self.uid_int == -1 and self.uid_str == &#34;&#34;:
        return True
    else:
        return False</code></pre>
</details>
</dd>
<dt id="vcd.core.UID.is_uuid"><code class="name flex">
<span>def <span class="ident">is_uuid</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_uuid(self):
    return self.uuid</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="vcd.core.VCD"><code class="flex name class">
<span>class <span class="ident">VCD</span></span>
<span>(</span><span>file_name=None, validation=False)</span>
</code></dt>
<dd>
<div class="desc"><p>VCD class as main container of VCD content. Exposes functions to
add Elements, to get information and to remove data.
Internally manages all information as Python dictionaries, and can map
data into JSON strings.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class VCD:
    &#34;&#34;&#34;
    VCD class as main container of VCD content. Exposes functions to
    add Elements, to get information and to remove data.
    Internally manages all information as Python dictionaries, and can map
    data into JSON strings.
    &#34;&#34;&#34;
    ##################################################
    # Constructor
    ##################################################
    def __init__(self, file_name=None, validation=False):
        self.use_uuid = False
        if file_name is not None:
            json_file = open(file_name)
            # In VCD 4.2.0, uids and frames were ints, so, parsing needed a lambda function to do the job
            # self.data = json.load(
            #    json_file,
            #    object_hook=lambda d: {int(k) if k.lstrip(&#39;-&#39;).isdigit() else k: v for k, v in d.items()}
            # )

            read_data = json.load(json_file)  # Open without converting strings to integers
            # Check VERSION
            if &#39;vcd&#39; in read_data:
                # This is 4.x
                if &#39;version&#39; in read_data[&#39;vcd&#39;]:
                    # This is 4.1-2
                    if read_data[&#39;vcd&#39;][&#39;version&#39;] == &#34;4.2.0&#34;:
                        # This is VCD 4.2.0
                        warnings.warn(&#34;WARNING: Converting VCD 4.2.0 to VCD 4.3.0. A full revision is recommended.&#34;)
                        # Convert frame entries to int
                        frames = read_data[&#39;vcd&#39;][&#39;frames&#39;]
                        if frames:  # So frames is not empty
                            read_data[&#39;vcd&#39;][&#39;frames&#39;] = {int(key): value for key, value in frames.items()}

                        self.reset()  # to init object
                        converter.ConverterVCD420toVCD430(read_data, self)  # self is modified internally

                    elif read_data[&#39;vcd&#39;][&#39;version&#39;] == &#34;4.1.0&#34;:
                        # This is VCD 4.1.0
                        raise Exception(&#34;ERROR: VCD 4.1.0 to VCD 4.3.0 conversion is not implemented.&#34;)
                        pass
                elif &#39;metadata&#39; in read_data[&#39;vcd&#39;]:
                    if &#39;schema_version&#39; in read_data[&#39;vcd&#39;][&#39;metadata&#39;]:
                        if read_data[&#39;vcd&#39;][&#39;metadata&#39;][&#39;schema_version&#39;] == &#34;4.3.0&#34;:
                            # This is VCD 4.3.0
                            self.data = read_data
                            if validation:
                                if not hasattr(self, &#39;schema&#39;):
                                    self.schema = schema.vcd_schema
                                validate(instance=self.data, schema=self.schema)  # Raises errors if not validated
                                json_file.close()

                            # In VCD 4.3.0 uids are strings, because they can be numeric strings, or UUIDs
                            # but frames are still ints, so let&#39;s parse like that
                            if &#39;frames&#39; in self.data[&#39;vcd&#39;]:
                                frames = self.data[&#39;vcd&#39;][&#39;frames&#39;]
                                if frames:  # So frames is not empty
                                    self.data[&#39;vcd&#39;][&#39;frames&#39;] = {int(key): value for key, value in frames.items()}
                        else:
                            raise Exception(&#34;ERROR: This vcd file does not seem to be 4.3.0 nor 4.2.0&#34;)
                    else:
                        raise Exception(&#34;ERROR: This vcd file does not seem to be 4.3.0 nor 4.2.0&#34;)
            elif &#39;VCD&#39; in read_data:
                # This is 3.x
                warnings.warn(&#34;WARNING: Converting VCD 3.3.0 to VCD 4.3.0. A full revision is recommended.&#34;)
                # Assuming this is VCD 3.3.0, let&#39;s load into VCD 4.3.0
                self.reset()  # to init object
                converter.ConverterVCD330toVCD430(read_data, self)  # self is modified internally

            # Close file
            json_file.close()

            # Final set-up
            self.__compute_last_uid()
        else:
            self.reset()

    def set_use_uuid(self, val):
        assert(isinstance(val, bool))
        self.use_uuid = val

    def reset(self):
        # Main VCD data
        self.data = {&#39;vcd&#39;: {}}
        self.data[&#39;vcd&#39;][&#39;metadata&#39;] = {}
        self.data[&#39;vcd&#39;][&#39;metadata&#39;][&#39;schema_version&#39;] = schema.vcd_schema_version

        # Schema information
        self.schema = schema.vcd_schema

        # Additional auxiliary structures
        self.__lastUID = dict()
        self.__lastUID[ElementType.object] = -1
        self.__lastUID[ElementType.action] = -1
        self.__lastUID[ElementType.event] = -1
        self.__lastUID[ElementType.context] = -1
        self.__lastUID[ElementType.relation] = -1

    def convert_to_vcd330(self):
        return converter.ConverterVCD430toVCD330(self.data)

    ##################################################
    # Private API: inner functions
    ##################################################
    def __get_uid_to_assign(self, element_type, uid):
        assert isinstance(element_type, ElementType)
        assert(isinstance(uid, UID))
        if uid.is_none():
            if self.use_uuid:
                # Let&#39;s use UUIDs
                uid_to_assign = UID(str(uuid.uuid4()))
            else:
                # Let&#39;s use integers
                self.__lastUID[element_type] += 1
                uid_to_assign = UID(self.__lastUID[element_type])
        else:
            # uid is not None
            assert(isinstance(uid, UID))
            if not uid.is_uuid():
                # Ok, user provided a number, let&#39;s proceed
                if uid.as_int() &gt; self.__lastUID[element_type]:
                    self.__lastUID[element_type] = uid.as_int()
                    uid_to_assign = UID(self.__lastUID[element_type])
                else:
                    uid_to_assign = uid
            else:
                # This is a UUID
                self.use_uuid = True
                uid_to_assign = uid

        return uid_to_assign

    def __set_vcd_frame_intervals(self, frame_intervals):
        assert(isinstance(frame_intervals, FrameIntervals))
        if not frame_intervals.empty():
            self.data[&#39;vcd&#39;][&#39;frame_intervals&#39;] = frame_intervals.get_dict()

    def __update_vcd_frame_intervals(self, frame_intervals):
        # This function creates the union of existing VCD with the input frameIntervals
        assert (isinstance(frame_intervals, FrameIntervals))
        if not frame_intervals.empty():
            if &#39;frame_intervals&#39; not in self.data[&#39;vcd&#39;]:
                self.data[&#39;vcd&#39;][&#39;frame_intervals&#39;] = []
            fis_current = FrameIntervals(self.data[&#39;vcd&#39;][&#39;frame_intervals&#39;])
            fis_union = fis_current.union(frame_intervals)
            self.__set_vcd_frame_intervals(fis_union)

    def __add_frame(self, frame_num):
        if &#39;frames&#39; not in self.data[&#39;vcd&#39;]:
            self.data[&#39;vcd&#39;][&#39;frames&#39;] = {}
        if frame_num not in self.data[&#39;vcd&#39;][&#39;frames&#39;]:
            self.data[&#39;vcd&#39;][&#39;frames&#39;][frame_num] = {}

    def __compute_last_uid(self):
        self.__lastUID = dict()
        # Read all objects and fill lastUID
        self.__lastUID[ElementType.object] = -1
        if &#39;objects&#39; in self.data[&#39;vcd&#39;]:
            for uid in self.data[&#39;vcd&#39;][&#39;objects&#39;]:
                if int(uid) &gt; self.__lastUID[ElementType.object]:
                    self.__lastUID[ElementType.object] = int(uid)

        self.__lastUID[ElementType.action] = -1
        if &#39;actions&#39; in self.data[&#39;vcd&#39;]:
            for uid in self.data[&#39;vcd&#39;][&#39;actions&#39;]:
                if int(uid) &gt; self.__lastUID[ElementType.action]:
                    self.__lastUID[ElementType.action] = int(uid)

        self.__lastUID[ElementType.event] = -1
        if &#39;events&#39; in self.data[&#39;vcd&#39;]:
            for uid in self.data[&#39;vcd&#39;][&#39;events&#39;]:
                if int(uid) &gt; self.__lastUID[ElementType.event]:
                    self.__lastUID[ElementType.event] = int(uid)

        self.__lastUID[ElementType.context] = -1
        if &#39;contexts&#39; in self.data[&#39;vcd&#39;]:
            for uid in self.data[&#39;vcd&#39;][&#39;contexts&#39;]:
                if int(uid) &gt; self.__lastUID[ElementType.context]:
                    self.__lastUID[ElementType.context] = int(uid)

        self.__lastUID[ElementType.relation] = -1
        if &#39;relations&#39; in self.data[&#39;vcd&#39;]:
            for uid in self.data[&#39;vcd&#39;][&#39;relations&#39;]:
                if int(uid) &gt; self.__lastUID[ElementType.relation]:  # uid is a string!
                    self.__lastUID[ElementType.relation] = int(uid)

    def __add_frames(self, frame_intervals, element_type, uid):
        assert(isinstance(frame_intervals, FrameIntervals))
        assert(isinstance(element_type, ElementType))
        assert(isinstance(uid, UID))
        if frame_intervals.empty():
            return
        else:
            # Loop over frames and add
            fis = frame_intervals.get()
            for fi in fis:
                for f in range(fi[0], fi[1]+1):
                    # Add frame
                    self.__add_frame(f)
                    # Add element entry
                    frame = self.get_frame(f)
                    frame.setdefault(element_type.name + &#39;s&#39;, {})
                    frame[element_type.name + &#39;s&#39;].setdefault(uid.as_str(), {})

    def __set_element(
            self, element_type, name, semantic_type, frame_intervals, uid, ont_uid,
            coordinate_system, set_mode
    ):
        assert (isinstance(uid, UID))
        assert (isinstance(ont_uid, UID))
        assert (isinstance(frame_intervals, FrameIntervals))
        assert (isinstance(set_mode, SetMode))

        fis = frame_intervals
        if set_mode == SetMode.union:
            # Union means fusion, we are calling this function to &#34;add&#34; content, not to remove any
            fis_existing = self.get_element_frame_intervals(element_type, uid.as_str())
            fis = fis_existing.union(frame_intervals)

        # 0.- Get uid_to_assign
        uid_to_assign = self.__get_uid_to_assign(element_type, uid)  # note: private functions use UID type for uids

        # 1.- Set the root entries and frames entries
        self.__set_element_at_root_and_frames(element_type, name, semantic_type, fis,
                                              uid_to_assign, ont_uid, coordinate_system)

        return uid_to_assign

    def __set_element_at_root_and_frames(
            self, element_type, name, semantic_type, frame_intervals, uid, ont_uid, coordinate_system
    ):
        # 1.- Copy from existing or create new entry (this copies everything, including element_data)
        # element_data_pointers and frame intervals
        uidstr = uid.as_str()
        element_existed = self.has(element_type, uidstr)# note: public functions use int or str for uids
        self.data[&#39;vcd&#39;].setdefault(element_type.name + &#39;s&#39;, {})
        self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;].setdefault(uidstr, {})
        element = self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;][uidstr]

        fis_old = FrameIntervals()
        if &#39;frame_intervals&#39; in element:
            fis_old = FrameIntervals(element[&#39;frame_intervals&#39;])

        # 2.- Copy from arguments
        if name is not None:
            element[&#39;name&#39;] = name
        if semantic_type is not None:
            element[&#39;type&#39;] = semantic_type
        if not frame_intervals.empty() or (element_existed and not fis_old.empty()):
            # So, either the newFis has something, or the fisOld had something (in which case needs to be substituted)
            # Under the previous control, no &#39;frame_intervals&#39; field is added to newly created static elements
            # -&gt; should &#39;frame_intervals&#39; be mandatory
            element[&#39;frame_intervals&#39;] = frame_intervals.get_dict()
        if not ont_uid.is_none() and self.get_ontology(ont_uid.as_str()):
            element[&#39;ontology_uid&#39;] = ont_uid.as_str()
        if coordinate_system is not None and self.has_coordinate_system(coordinate_system):
            element[&#39;coordinate_system&#39;] = coordinate_system

        # 2.bis.- For Relations obligue to have rdf_objects and rdf_subjects entries (to be compliant with schema)
        if element_type is ElementType.relation:
            if &#39;rdf_subjects&#39; not in element:
                element[&#39;rdf_subjects&#39;] = []
            if &#39;rdf_objects&#39; not in element:
                element[&#39;rdf_objects&#39;] = []

        # 3.- Reshape element_data_pointers according to this new frame intervals
        if element_type.name + &#39;_data_pointers&#39; in element:
            edps = element[element_type.name + &#39;_data_pointers&#39;]
            for edp_name in edps:
                # NOW, we have to UPDATE frame intervals of pointers because we have modified the frame_intervals
                # of the element itself, adn
                # If we compute the intersection frame_intervals, we can copy that into
                # element_data_pointers frame intervals
                fis_int = FrameIntervals()
                if not frame_intervals.empty():
                    fis_int = frame_intervals.intersection(FrameIntervals(edps[edp_name][&#39;frame_intervals&#39;]))

                # Update the pointers
                element.setdefault(element_type.name + &#39;_data_pointers&#39;, {})
                element[element_type.name + &#39;_data_pointers&#39;][edp_name] = edps[edp_name]
                element[element_type.name + &#39;_data_pointers&#39;][edp_name][&#39;frame_intervals&#39;] = fis_int.get_dict()

        # 4.- Now set at frames
        if not frame_intervals.empty():
            # 2.1.- There is frame_intervals specified
            if not element_existed:
                # 2.1.a) Just create the new element
                self.__add_frames(frame_intervals, element_type, uid)
                self.__update_vcd_frame_intervals(frame_intervals)
            else:
                # 2.1.b) This is a substitution: depending on the new frame_intervals, we may need to delete/add frames
                # Add
                fis_new = frame_intervals
                for fi in fis_new.get():
                    for f in range(fi[0], fi[1] + 1):
                        is_inside = fis_old.has_frame(f)
                        if not is_inside:
                            # New frame is not inside -&gt; let&#39;s add this frame
                            fi_ = FrameIntervals(f)
                            self.__add_frames(fi_, element_type, uid)
                            self.__update_vcd_frame_intervals(fi_)
                # Remove
                if element_existed and fis_old.empty():
                    # Ok, the element was originally static (thus with fisOld empty)
                    # so potentially there are pointers of the element in all frames (in case there are frames)
                    # Now the element is declared with a specific frame intervals. Then we first need to remove all
                    # element entries (pointers) in all OTHER frames
                    vcd_frame_intervals = self.get_frame_intervals()
                    if not vcd_frame_intervals.empty():
                        for fi in vcd_frame_intervals.get():
                            for f in range(fi[0], fi[1] + 1):
                                if not fis_new.has_frame(f):  # Only for those OTHER frames not those just added
                                    elements_in_frame = self.data[&#39;vcd&#39;][&#39;frames&#39;][f][element_type.name + &#39;s&#39;]
                                    if uidstr in elements_in_frame:
                                        del elements_in_frame[uidstr]
                                        if len(elements_in_frame) == 0:
                                            del self.data[&#39;vcd&#39;][&#39;frames&#39;][f][element_type.name + &#39;s&#39;]
                                            if len(self.data[&#39;vcd&#39;][&#39;frames&#39;][f]) == 0:
                                                self.__rm_frame(f)

                # Next loop for is for the case fis_old wasn&#39;t empty, so we just need to remove old content
                for fi in fis_old.get():
                    for f in range(fi[0], fi[1] + 1):
                        is_inside = fis_new.has_frame(f)
                        if not is_inside:
                            # Old frame not inside new ones -&gt; let&#39;s remove this frame
                            elements_in_frame = self.data[&#39;vcd&#39;][&#39;frames&#39;][f][element_type.name + &#39;s&#39;]
                            del elements_in_frame[uidstr]
                            if len(elements_in_frame) == 0:
                                del self.data[&#39;vcd&#39;][&#39;frames&#39;][f][element_type.name + &#39;s&#39;]
                                if len(self.data[&#39;vcd&#39;][&#39;frames&#39;][f]) == 0:
                                    self.__rm_frame(f)
        else:
            # 2.2.- The element is declared as static
            if element_type is not ElementType.relation:  # frame-less relation must remain frame-less
                vcd_frame_intervals = self.get_frame_intervals()
                if not vcd_frame_intervals.empty():
                    # ... but VCD has already other elements or info that have established some frame intervals
                    # The element is then assumed to exist in all frames: let&#39;s add a pointer into all frames
                    self.__add_frames(vcd_frame_intervals, element_type, uid)

            # But, if the element existed previously, and it was dynamic, there is already information inside frames.
            # If there is element_data at frames, they are removed
            if not fis_old.empty():
                self.rm_element_data_from_frames(element_type, uid, fis_old)

                # Additionally, we need to remove element entries at frames, and frames entirely to clean-up
                for fi in fis_old.get():
                    for f in range(fi[0], fi[1] + 1):
                        elements_in_frame = self.data[&#39;vcd&#39;][&#39;frames&#39;][f][element_type.name + &#39;s&#39;]
                        del elements_in_frame[uidstr]
                        # Clean-up
                        if len(elements_in_frame) == 0:
                            del self.data[&#39;vcd&#39;][&#39;frames&#39;][f][element_type.name + &#39;s&#39;]
                            if len(self.data[&#39;vcd&#39;][&#39;frames&#39;][f]) == 0:
                                self.__rm_frame(f)

    def __set_element_data(self, element_type, uid, element_data, frame_intervals, set_mode):
        assert(isinstance(uid, UID))
        assert(isinstance(frame_intervals, FrameIntervals))
        assert(isinstance(set_mode, SetMode))

        # 0.- Checks
        if not self.has(element_type, uid.as_str()):
            warnings.warn(&#34;WARNING: Trying to set element_data for a non-existing element.&#34;)
            return
        element = self.get_element(element_type, uid.as_str())

        # Read existing data about this element, so we can call __set_element
        name = element[&#39;name&#39;]
        semantic_type = element[&#39;type&#39;]
        ont_uid = UID(None)
        cs = None
        if &#39;ontology_uid&#39; in element:
            ont_uid = UID(element[&#39;ontology_uid&#39;])
        if &#39;coordinate_system&#39; in element:
            cs = element[&#39;coordinate_system&#39;]

        if &#39;coordinate_system&#39; in element_data.data:
            if not self.has_coordinate_system(element_data.data[&#39;coordinate_system&#39;]):
                warnings.warn(&#34;WARNING: Trying to set element_data with a non-declared coordinate system.&#34;)
                return

        if frame_intervals.empty() and set_mode == SetMode.union and not isinstance(element_data, types.mesh):
            set_mode = SetMode.replace

        if set_mode == SetMode.replace:
            # Extend also the container Element just in case the frame_interval of this element_data is beyond it
            # removes/creates frames if needed
            # This call is to modify an existing element_data, which may imply removing some frames
            if not frame_intervals.empty():
                fis_existing = FrameIntervals(element[&#39;frame_intervals&#39;])
                fis_new = frame_intervals
                fis_union = fis_existing.union(fis_new)
                self.__set_element(element_type, name, semantic_type, fis_union, uid, ont_uid, cs, set_mode)
                self.__set_element_data_content_at_frames(element_type, uid, element_data, frame_intervals)
            else:
                # This is a static element_data. If it was declared dynamic before, let&#39;s remove it
                #self.__set_element(element_type, name, semantic_type, frame_intervals, uid, ont_uid, cs, set_mode)
                if self.has_element_data(element_type, uid.as_str(), element_data):
                    fis_old = self.get_element_data_frame_intervals(element_type, uid.as_str(), element_data.data[&#39;name&#39;])
                    if not fis_old.empty():
                        self.rm_element_data_from_frames_by_name(element_type, uid, element_data.data[&#39;name&#39;], fis_old)
                self.__set_element_data_content(element_type, element, element_data)
            # Set the pointers
            self.__set_element_data_pointers(element_type, uid, element_data, frame_intervals)
        else:  # set_mode = SetMode.union
            # This call is to add element_data to the element, substituting content if overlap, otherwise adding
            # First, extend also the container Element just in case the frame_interval of this element_data is beyond
            # the currently existing frame_intervals of the Element
            # internally computes the union
            self.__set_element(element_type, name, semantic_type, frame_intervals, uid, ont_uid, cs, set_mode)

            if not frame_intervals.empty():
                fis_existing = FrameIntervals()
                if element_type.name + &#39;_data_pointers&#39; in element:
                    edp = element[element_type.name + &#39;_data_pointers&#39;]
                    if element_data.data[&#39;name&#39;] in edp:
                        fis_existing = FrameIntervals(edp[element_data.data[&#39;name&#39;]][&#39;frame_intervals&#39;])
                fis_new = frame_intervals
                fis_union = fis_existing.union(fis_new)

                # Dynamic
                if element is not None:
                    # It is not a simple call with the union of frame intervals
                    # We need to substitute the content for just this frame_interval, without modifying the rest
                    # that must stay as it was
                    # Loop over the specified frame_intervals to create or substitute the content
                    self.__set_element_data_content_at_frames(element_type, uid, element_data, fis_new)

                # Set the pointers (but the pointers we have to update using the union)
                self.__set_element_data_pointers(element_type, uid, element_data, fis_union)
            elif isinstance(element_data, types.mesh):
                # This is only for mesh case that can have this static part
                # (because it is an object data type which is both static and dynamic)
                self.__set_element_data_content(element_type, element, element_data)

    def __set_element_data_content_at_frames(self, element_type, uid, element_data, frame_intervals):
        # Loop over the specified frame_intervals to create or substitute the content
        # Create entries of the element_data at frames
        fis = frame_intervals.get()
        for fi in fis:
            for f in range(fi[0], fi[1] + 1):
                # Add element_data entry
                frame = self.get_frame(f)
                if frame is None:
                    self.__add_frame(f)
                    frame = self.get_frame(f)

                frame.setdefault(element_type.name + &#39;s&#39;, {})
                frame[element_type.name + &#39;s&#39;].setdefault(uid.as_str(), {})
                element = frame[element_type.name + &#39;s&#39;][uid.as_str()]
                self.__set_element_data_content(element_type, element, element_data)

    @staticmethod
    def __set_element_data_content(element_type, element, element_data):
        # Adds the element_data to the corresponding container
        # If an element_data with same name exists, it is substituted
        element.setdefault(element_type.name + &#39;_data&#39;, {})
        element[element_type.name + &#39;_data&#39;].setdefault(element_data.type.name, [])
        # Find if element_data already there
        list_aux = element[element_type.name + &#39;_data&#39;][element_data.type.name]
        pos_list = [idx for idx, val in enumerate(list_aux) if val[&#39;name&#39;] == element_data.data[&#39;name&#39;]]

        if len(pos_list) == 0:
            # Not found, then just push this new element data
            element[element_type.name + &#39;_data&#39;][element_data.type.name].append(element_data.data)
        else:
            # Found: let&#39;s substitute
            pos = pos_list[0]
            element[element_type.name + &#39;_data&#39;][element_data.type.name][pos] = element_data.data

    def __set_element_data_pointers(self, element_type, uid, element_data, frame_intervals):
        assert(isinstance(uid, UID))
        self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;][uid.as_str()].setdefault(element_type.name + &#39;_data_pointers&#39;, {})
        edp = self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;][uid.as_str()][element_type.name + &#39;_data_pointers&#39;]
        edp[element_data.data[&#39;name&#39;]] = {}
        edp[element_data.data[&#39;name&#39;]][&#39;type&#39;] = element_data.type.name
        if frame_intervals is None:
            edp[element_data.data[&#39;name&#39;]][&#39;frame_intervals&#39;] = []
        else:
            edp[element_data.data[&#39;name&#39;]][&#39;frame_intervals&#39;] = frame_intervals.get_dict()
        if &#39;attributes&#39; in element_data.data:
            edp[element_data.data[&#39;name&#39;]][&#39;attributes&#39;] = {}
            for attr_type in element_data.data[&#39;attributes&#39;]:  # attr_type might be &#39;boolean&#39;, &#39;text&#39;, &#39;num&#39;, or &#39;vec&#39;
                for attr in element_data.data[&#39;attributes&#39;][attr_type]:
                    edp[element_data.data[&#39;name&#39;]][&#39;attributes&#39;][attr[&#39;name&#39;]] = attr_type

    def __rm_frame(self, frame_num):
        # This function deletes a frame entry from frames, and updates VCD accordingly
        if &#39;frames&#39; in self.data[&#39;vcd&#39;]:
            if frame_num in self.data[&#39;vcd&#39;][&#39;frames&#39;]:
                del self.data[&#39;vcd&#39;][&#39;frames&#39;][frame_num]
            if len(self.data[&#39;vcd&#39;][&#39;frames&#39;]) == 0:
                del self.data[&#39;vcd&#39;][&#39;frames&#39;]

        # Remove from VCD frame intervals
        if &#39;frame_intervals&#39; in self.data[&#39;vcd&#39;]:
            fis_dict = self.data[&#39;vcd&#39;][&#39;frame_intervals&#39;]
            fis_dict_new = utils.rm_frame_from_frame_intervals(fis_dict, frame_num)

            # Now substitute
            if len(fis_dict_new) == 0:
                del self.data[&#39;vcd&#39;][&#39;frame_intervals&#39;]
            else:
                self.data[&#39;vcd&#39;][&#39;frame_intervals&#39;] = fis_dict_new


    def __compute_data_pointers(self):
        # WARNING! This function might be extremely slow
        # It does loop over all frames, and updates data pointers at objects, actions, etc
        # It is useful to convert from VCD 4.2.0 into VCD 4.3.0 (use converter.ConverterVCD420toVCD430)

        # Looping over frames and creating the necessary data_pointers
        if &#39;frame_intervals&#39; in self.data[&#39;vcd&#39;]:
            fis = self.data[&#39;vcd&#39;][&#39;frame_intervals&#39;]
            for fi in fis:
                for frame_num in range(fi[&#39;frame_start&#39;], fi[&#39;frame_end&#39;] + 1):
                    frame = self.get_frame(frame_num)
                    for element_type in ElementType:
                        if element_type.name + &#39;s&#39; in frame:  # e.g. &#34;objects&#34;, &#34;actions&#34;...
                            for uid, element in frame[element_type.name + &#39;s&#39;].items():
                                if element_type.name + &#39;_data&#39; in element:
                                    # So this element has element_data in this frame
                                    # and then we need to update the element_data_pointer at the root
                                    # we can safely assume it already exists

                                    # First, let&#39;s create a element_data_pointer at the root
                                    self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;][uid].\
                                        setdefault(element_type.name + &#39;_data_pointers&#39;, {})
                                    edp = self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;][uid]
                                    [element_type.name + &#39;_data_pointers&#39;]

                                    # Let&#39;s loop over the element_data
                                    for ed_type, ed_array in element[element_type.name + &#39;_data&#39;].items():
                                        # e.g. ed_type is &#39;bbox&#39;, ed_array is the array of such bboxes content
                                        for element_data in ed_array:
                                            name = element_data[&#39;name&#39;]
                                            edp.setdefault(name, {})  # this element_data may already exist
                                            edp[name].setdefault(&#39;type&#39;, ed_type)  # e.g. &#39;bbox&#39;
                                            edp[name].setdefault(&#39;frame_intervals&#39;, [])  # in case it does not exist
                                            fis_exist = FrameIntervals(edp[name][&#39;frame_intervals&#39;])
                                            fis_exist.union(FrameIntervals(frame_num))  # So, let&#39;s fuse with this frame
                                            edp[name][&#39;frame_intervals&#39;] = fis_exist.get_dict()  # overwrite
                                            # No need to manage attributes

    def rm_element_data_from_frames_by_name(self, element_type, uid, element_data_name, frame_intervals):
        for fi in frame_intervals.get():
            for f in range(fi[0], fi[1] + 1):
                if self.has_frame(f):
                    frame = self.data[&#39;vcd&#39;][&#39;frames&#39;][f]
                    if element_type.name + &#39;s&#39; in frame:
                        if uid.as_str() in frame[element_type.name + &#39;s&#39;]:
                            element = frame[element_type.name + &#39;s&#39;][uid.as_str()]
                            if element_type.name + &#39;_data&#39; in element:
                                # Delete only the element_data with the specified name
                                for prop in element[element_type.name + &#39;_data&#39;]:
                                    val_array = element[element_type.name + &#39;_data&#39;][prop]
                                    for i in range(0, len(val_array)):
                                        val = val_array[i]
                                        if val[&#39;name&#39;] == element_data_name:
                                            del element[element_type.name + &#39;_data&#39;][prop][i]

    def rm_element_data_from_frames(self, element_type, uid, frame_intervals):
        for fi in frame_intervals.get():
            for f in range(fi[0], fi[1] + 1):
                if self.has_frame(f):
                    frame = self.data[&#39;vcd&#39;][&#39;frames&#39;][f]
                    if element_type.name + &#39;s&#39; in frame:
                        if uid.as_str() in frame[element_type.name + &#39;s&#39;]:
                            element = frame[element_type.name + &#39;s&#39;][uid.as_str()]
                            if element_type.name + &#39;_data&#39; in element:
                                # Delete all its former dyamic element_data entries at old fis
                                del element[element_type.name + &#39;_data&#39;]

        # Clean-up data pointers of object_data that no longer exist!
        # Note, element_data_pointers are correctly updated, but there might be some now declared as static
        # corresponding to element_data that was dynamic but now has been removed when the element changed to static
        if self.has(element_type, uid.as_str()):
            element = self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;][uid.as_str()]
            if element_type.name + &#39;_data_pointers&#39; in element:
                edps = element[element_type.name + &#39;_data_pointers&#39;]
                edp_names_to_delete = []
                for edp_name in edps:
                    fis_ed = FrameIntervals(edps[edp_name][&#39;frame_intervals&#39;])
                    if fis_ed.empty():
                        # Check if element_data exists
                        ed_type = edps[edp_name][&#39;type&#39;]
                        found = False
                        if element_type.name + &#39;_data&#39; in element:
                            if ed_type in element[element_type.name + &#39;_data&#39;]:
                                for ed in element[element_type.name + &#39;_data&#39;][ed_type]:
                                    if ed[&#39;name&#39;] == edp_name:
                                        found = True
                                        break
                        if not found:
                            edp_names_to_delete.append(edp_name)
                for edp_name in edp_names_to_delete:
                    del element[element_type.name + &#39;_data_pointers&#39;][edp_name]

    ##################################################
    # Public API: add, update
    ##################################################
    def add_file_version(self, version):
        assert (type(version) is str)
        if &#39;metadata&#39; not in self.data[&#39;vcd&#39;]:
            self.data[&#39;vcd&#39;][&#39;metadata&#39;] = {}
        self.data[&#39;vcd&#39;][&#39;metadata&#39;][&#39;file_version&#39;] = version

    def add_metadata_properties(self, properties):
        assert(isinstance(properties, dict))
        prop = self.data[&#39;vcd&#39;][&#39;metadata&#39;]
        prop.update(properties)

    def add_name(self, name):
        assert(type(name) is str)
        if &#39;metadata&#39; not in self.data[&#39;vcd&#39;]:
            self.data[&#39;vcd&#39;][&#39;metadata&#39;] = {}
        self.data[&#39;vcd&#39;][&#39;metadata&#39;][&#39;name&#39;] = name

    def add_annotator(self, annotator):
        assert(type(annotator) is str)
        if &#39;metadata&#39; not in self.data[&#39;vcd&#39;]:
            self.data[&#39;vcd&#39;][&#39;metadata&#39;] = {}
        self.data[&#39;vcd&#39;][&#39;metadata&#39;][&#39;annotator&#39;] = annotator

    def add_comment(self, comment):
        assert(type(comment) is str)
        if &#39;metadata&#39; not in self.data[&#39;vcd&#39;]:
            self.data[&#39;vcd&#39;][&#39;metadata&#39;] = {}
        self.data[&#39;vcd&#39;][&#39;metadata&#39;][&#39;comment&#39;] = comment

    def add_ontology(self, ontology_name):
        self.data[&#39;vcd&#39;].setdefault(&#39;ontologies&#39;, dict())
        for ont_uid in self.data[&#39;vcd&#39;][&#39;ontologies&#39;]:
            if self.data[&#39;vcd&#39;][&#39;ontologies&#39;][ont_uid] == ontology_name:
                warnings.warn(&#39;WARNING: adding an already existing ontology&#39;)
                return None
        length = len(self.data[&#39;vcd&#39;][&#39;ontologies&#39;])
        self.data[&#39;vcd&#39;][&#39;ontologies&#39;][str(length)] = ontology_name
        return str(length)

    def add_coordinate_system(self, name, cs_type, parent_name=&#34;&#34;, pose_wrt_parent=[], uid=None):
        assert(isinstance(cs_type, types.CoordinateSystemType))
        # Create entry
        self.data[&#39;vcd&#39;].setdefault(&#39;coordinate_systems&#39;, {})
        self.data[&#39;vcd&#39;][&#39;coordinate_systems&#39;][name] = {&#39;type&#39;: cs_type.name,
                                                        &#39;parent&#39;: parent_name,
                                                        &#39;pose_wrt_parent&#39;: pose_wrt_parent,
                                                        &#39;children&#39;: []}
        if uid is not None:
            assert(isinstance(uid, str))
            self.data[&#39;vcd&#39;][&#39;coordinate_systems&#39;][name].update({&#34;uid&#34;: uid})

        # Update parents
        if parent_name != &#34;&#34;:
            found = False
            for n, cs in self.data[&#39;vcd&#39;][&#39;coordinate_systems&#39;].items():
                if n == parent_name:
                    found = True
                    cs[&#39;children&#39;].append(name)
            if not found:
                warnings.warn(&#34;WARNING: Creating a coordinate system with a non-defined parent coordinate system.&#34;
                              &#34;Coordinate systems must be introduced in order&#34;)

    def add_transform(self, frame_num, transform):
        assert (isinstance(frame_num, int))
        assert(isinstance(transform, types.Transform))

        self.__add_frame(frame_num)  # this function internally checks if the frame already exists
        self.data[&#39;vcd&#39;][&#39;frames&#39;][frame_num].setdefault(&#39;frame_properties&#39;, dict())
        self.data[&#39;vcd&#39;][&#39;frames&#39;][frame_num][&#39;frame_properties&#39;].setdefault(&#39;transforms&#39;, dict())
        self.data[&#39;vcd&#39;][&#39;frames&#39;][frame_num][&#39;frame_properties&#39;][&#39;transforms&#39;].update(transform.data)

    def add_stream(self, stream_name, uri, description, stream_type):
        assert(isinstance(stream_name, str))
        assert(isinstance(uri, str))
        assert(isinstance(description, str))

        self.data[&#39;vcd&#39;].setdefault(&#39;streams&#39;, dict())
        self.data[&#39;vcd&#39;][&#39;streams&#39;].setdefault(stream_name, dict())
        if isinstance(stream_type, StreamType):
            self.data[&#39;vcd&#39;][&#39;streams&#39;][stream_name] = {
                &#39;description&#39;: description, &#39;uri&#39;: uri, &#39;type&#39;: stream_type.name
            }
        elif isinstance(stream_type, str):
            self.data[&#39;vcd&#39;][&#39;streams&#39;][stream_name] = {
                &#39;description&#39;: description, &#39;uri&#39;: uri, &#39;type&#39;: stream_type
            }

    def add_frame_properties(self, frame_num, timestamp=None, properties=None):
        self.__add_frame(frame_num)  # this function internally checks if the frame already exists
        self.data[&#39;vcd&#39;][&#39;frames&#39;][frame_num].setdefault(&#39;frame_properties&#39;, dict())
        if timestamp is not None:
            assert (isinstance(timestamp, str))
            self.data[&#39;vcd&#39;][&#39;frames&#39;][frame_num][&#39;frame_properties&#39;][&#39;timestamp&#39;] = timestamp

        if properties is not None:
            assert (isinstance(properties, dict))
            self.data[&#39;vcd&#39;][&#39;frames&#39;][frame_num][&#39;frame_properties&#39;].update(properties)

    def add_stream_properties(self, stream_name, properties=None, intrinsics=None, stream_sync=None):
        has_arguments = False
        if intrinsics is not None:
            assert(isinstance(intrinsics, types.Intrinsics))
            has_arguments = True
        if properties is not None:
            assert(isinstance(properties, dict))  # &#34;Properties of Stream should be defined as a dictionary&#34;
            has_arguments = True
        if stream_sync is not None:
            assert(isinstance(stream_sync, types.StreamSync))
            has_arguments = True
            if stream_sync.frame_vcd is not None:
                frame_num = stream_sync.frame_vcd
            else:
                frame_num = None
        else:
            frame_num = None

        if not has_arguments:
            return

        # This function can be used to add stream properties. If frame_num is defined, the information is embedded
        # inside &#39;frame_properties&#39; of the specified frame. Otherwise, the information is embedded into
        # &#39;stream_properties&#39; inside &#39;metadata&#39;.

        # Find if this stream is declared
        if &#39;metadata&#39; in self.data[&#39;vcd&#39;]:
            if &#39;streams&#39; in self.data[&#39;vcd&#39;]:
                if stream_name in self.data[&#39;vcd&#39;][&#39;streams&#39;]:
                    if frame_num is None:
                        # This information is static
                        self.data[&#39;vcd&#39;][&#39;streams&#39;][stream_name].setdefault(&#39;stream_properties&#39;, dict())
                        if properties is not None:
                            self.data[&#39;vcd&#39;][&#39;streams&#39;][stream_name][&#39;stream_properties&#39;].\
                                update(properties)
                        if intrinsics is not None:
                            self.data[&#39;vcd&#39;][&#39;streams&#39;][stream_name][&#39;stream_properties&#39;].\
                                update(intrinsics.data)
                        if stream_sync is not None:
                            if stream_sync.data:
                                self.data[&#39;vcd&#39;][&#39;streams&#39;][stream_name][&#39;stream_properties&#39;].\
                                    update(stream_sync.data)
                    else:
                        # This is information of the stream for a specific frame
                        self.__add_frame(frame_num)  # to add the frame in case it does not exist
                        frame = self.data[&#39;vcd&#39;][&#39;frames&#39;][frame_num]
                        frame.setdefault(&#39;frame_properties&#39;, dict())
                        frame[&#39;frame_properties&#39;].setdefault(&#39;streams&#39;, dict())
                        frame[&#39;frame_properties&#39;][&#39;streams&#39;].setdefault(stream_name, dict())
                        frame[&#39;frame_properties&#39;][&#39;streams&#39;][stream_name].setdefault(&#39;stream_properties&#39;, dict())
                        if properties is not None:
                            frame[&#39;frame_properties&#39;][&#39;streams&#39;][stream_name][&#39;stream_properties&#39;].\
                                update(properties)
                        if intrinsics is not None:
                            frame[&#39;frame_properties&#39;][&#39;streams&#39;][stream_name][&#39;stream_properties&#39;].\
                                update(intrinsics.data)

                        if stream_sync.data:
                            frame[&#39;frame_properties&#39;][&#39;streams&#39;][stream_name][&#39;stream_properties&#39;].\
                                update(stream_sync.data)
                else:
                    warnings.warn(&#39;WARNING: Trying to add stream properties for non-existing stream. &#39;
                                  &#39;Use add_stream first.&#39;)

    def save_frame(self, frame_num, file_name, dynamic_only=True, pretty=False):
        string = self.stringify_frame(frame_num, dynamic_only, pretty)
        file = open(file_name, &#39;w&#39;)
        file.write(string)
        file.close()

    def save(self, file_name, pretty=False, validate=False):
        string = self.stringify(pretty, validate)
        file = open(file_name, &#39;w&#39;)
        file.write(string)
        file.close()

    def validate(self, stringified_vcd):
        temp = json.loads(stringified_vcd)
        if not hasattr(self, &#39;schema&#39;):
            self.schema = schema.vcd_schema
        validate(instance=temp, schema=self.schema)

    def stringify(self, pretty=True, validate=True):
        if pretty:
            stringified_vcd = json.dumps(self.data, indent=4, sort_keys=False)

        else:
            stringified_vcd = json.dumps(self.data, separators=(&#39;,&#39;, &#39;:&#39;), sort_keys=False)
        if validate:
            self.validate(stringified_vcd)
        return stringified_vcd

    def stringify_frame(self, frame_num, dynamic_only=True, pretty=False):
        if frame_num not in self.data[&#39;vcd&#39;][&#39;frames&#39;]:
            warnings.warn(&#34;WARNING: Trying to stringify a non-existing frame.&#34;)
            return &#39;&#39;

        if dynamic_only:
            if pretty:
                return json.dumps(self.data[&#39;vcd&#39;][&#39;frames&#39;][frame_num], indent=4, sort_keys=True)
            else:
                return json.dumps(self.data[&#39;vcd&#39;][&#39;frames&#39;][frame_num])

        else:
            # Need to compose dynamic and static information into a new structure
            # Copy the dynamic info first
            frame_static_dynamic = copy.deepcopy(self.data[&#39;vcd&#39;][&#39;frames&#39;][frame_num])  # Needs to be a copy!

            # Now the static info for objects, actions, events, contexts and relations
            # Relations can be frame-less or frame-specific
            for element_type in ElementType:
                # First, elements explicitly defined for this frame
                if element_type.name + &#39;s&#39; in self.data[&#39;vcd&#39;][&#39;frames&#39;][frame_num]:
                    for uid, content in self.data[&#39;vcd&#39;][&#39;frames&#39;][frame_num][element_type.name + &#39;s&#39;].items():
                        frame_static_dynamic[element_type.name + &#39;s&#39;][uid].update(
                            self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;][uid]
                        )
                        # Remove frameInterval entry
                        if &#39;frame_intervals&#39; in frame_static_dynamic[element_type.name + &#39;s&#39;][uid]:
                            del frame_static_dynamic[element_type.name + &#39;s&#39;][uid][&#39;frame_intervals&#39;]

                # But also other elements without frame intervals specified, which are assumed to exist during
                # the entire sequence, except frame-less Relations which are assumed to not be associated to any frame
                if element_type.name + &#39;s&#39; in self.data[&#39;vcd&#39;] and element_type.name != &#39;relation&#39;:
                    for uid, element in self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;].items():
                        frame_intervals_dict = element.get(&#39;frame_intervals&#39;)
                        if frame_intervals_dict is None or not frame_intervals_dict:
                            # So the list of frame intervals is empty -&gt; this element lives the entire scene
                            # Let&#39;s add it to frame_static_dynamic
                            frame_static_dynamic.setdefault(element_type.name + &#39;s&#39;, dict()) # in case there are no
                                                                        # such type of elements already in this frame
                            frame_static_dynamic[element_type.name + &#39;s&#39;][uid] = dict()
                            frame_static_dynamic[element_type.name + &#39;s&#39;][uid] = copy.deepcopy(element)

                            # Remove frameInterval entry
                            if &#39;frame_intervals&#39; in frame_static_dynamic[element_type.name + &#39;s&#39;][uid]:
                                del frame_static_dynamic[element_type.name + &#39;s&#39;][uid][&#39;frame_intervals&#39;]

            if pretty:
                return json.dumps(frame_static_dynamic, indent=4, sort_keys=True)
            else:
                return json.dumps(frame_static_dynamic)

    def add_object(self, name, semantic_type=&#39;&#39;, frame_value=None, uid=None, ont_uid=None, coordinate_system=None,
                   set_mode=SetMode.union):
        return self.__set_element(ElementType.object, name, semantic_type, FrameIntervals(frame_value),
                                  UID(uid), UID(ont_uid), coordinate_system, set_mode).as_str()

    def add_action(self, name, semantic_type=&#39;&#39;, frame_value=None, uid=None, ont_uid=None, coordinate_system=None,
                   set_mode=SetMode.union):
        return self.__set_element(ElementType.action, name, semantic_type, FrameIntervals(frame_value),
                                  UID(uid), UID(ont_uid), coordinate_system, set_mode).as_str()

    def add_event(self, name, semantic_type=&#39;&#39;, frame_value=None, uid=None, ont_uid=None, coordinate_system=None,
                  set_mode=SetMode.union):
        return self.__set_element(ElementType.event, name, semantic_type, FrameIntervals(frame_value),
                                  UID(uid), UID(ont_uid), coordinate_system, set_mode).as_str()

    def add_context(self, name, semantic_type=&#39;&#39;, frame_value=None, uid=None, ont_uid=None, coordinate_system=None,
                    set_mode=SetMode.union):
        return self.__set_element(ElementType.context, name, semantic_type, FrameIntervals(frame_value),
                                  UID(uid), UID(ont_uid), coordinate_system, set_mode).as_str()

    def add_relation(self, name, semantic_type=&#39;&#39;, frame_value=None, uid=None, ont_uid=None,
                     set_mode=SetMode.union):
        if set_mode == SetMode.replace and uid is not None:
            if self.has(ElementType.relation, uid):
                relation = self.data[&#39;vcd&#39;][&#39;relations&#39;][UID(uid).as_str()]
                relation[&#39;rdf_subjects&#39;] = []
                relation[&#39;rdf_objects&#39;] = []

        relation_uid = self.__set_element(
            ElementType.relation, name, semantic_type, frame_intervals=FrameIntervals(frame_value),
            uid=UID(uid), ont_uid=UID(ont_uid), set_mode=set_mode, coordinate_system=None)
        return relation_uid.as_str()

    def add_element(self, element_type, name, semantic_type=&#39;&#39;, frame_value=None, uid=None, ont_uid=None, coordinate_system=None,
                    set_mode=SetMode.union):
        return self.__set_element(element_type, name, semantic_type, FrameIntervals(frame_value),
                                  UID(uid), UID(ont_uid), coordinate_system, set_mode).as_str()

    def add_rdf(self, relation_uid, rdf_type, element_uid, element_type):
        assert(isinstance(element_type, ElementType))
        assert(isinstance(rdf_type, RDF))
        rel_uid = UID(relation_uid)
        el_uid = UID(element_uid)
        if rel_uid.as_str() not in self.data[&#39;vcd&#39;][&#39;relations&#39;]:
            warnings.warn(&#34;WARNING: trying to add RDF to non-existing Relation.&#34;)
            return
        else:
            relation = self.data[&#39;vcd&#39;][&#39;relations&#39;][rel_uid.as_str()]
            if el_uid.as_str() not in self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;]:
                warnings.warn(&#34;WARNING: trying to add RDF using non-existing Element.&#34;)
                return
            else:
                if rdf_type == RDF.subject:
                    relation.setdefault(&#39;rdf_subjects&#39;, [])
                    relation[&#39;rdf_subjects&#39;].append(
                        {&#39;uid&#39;: el_uid.as_str(), &#39;type&#39;: element_type.name}
                    )
                else:
                    relation.setdefault(&#39;rdf_objects&#39;, [])
                    relation[&#39;rdf_objects&#39;].append(
                        {&#39;uid&#39;: el_uid.as_str(), &#39;type&#39;: element_type.name}
                    )

    def add_relation_object_action(self, name, semantic_type, object_uid, action_uid, relation_uid=None,
                                   ont_uid=None, frame_value=None, set_mode=SetMode.union):
        # Note: no need to wrap uids as UID, since all calls are public functions, and no access to dict is done.
        relation_uid = self.add_relation(name, semantic_type, uid=relation_uid, ont_uid=ont_uid,
                                         frame_value=frame_value, set_mode=set_mode)
        self.add_rdf(relation_uid=relation_uid, rdf_type=RDF.subject,
                     element_uid=object_uid, element_type=ElementType.object)
        self.add_rdf(relation_uid=relation_uid, rdf_type=RDF.object,
                     element_uid=action_uid, element_type=ElementType.action)

        return relation_uid

    def add_relation_action_action(self, name, semantic_type, action_uid_1, action_uid_2, relation_uid=None,
                                   ont_uid=None, frame_value=None, set_mode=SetMode.union):
        # Note: no need to wrap uids as UID, since all calls are public functions, and no access to dict is done.
        relation_uid = self.add_relation(name, semantic_type, uid=relation_uid, ont_uid=ont_uid,
                                         frame_value=frame_value, set_mode=set_mode)
        self.add_rdf(relation_uid=relation_uid, rdf_type=RDF.subject,
                     element_uid=action_uid_1, element_type=ElementType.action)
        self.add_rdf(relation_uid=relation_uid, rdf_type=RDF.object,
                     element_uid=action_uid_2, element_type=ElementType.action)

        return relation_uid

    def add_relation_object_object(self, name, semantic_type, object_uid_1, object_uid_2, relation_uid=None,
                                   ont_uid=None, frame_value=None, set_mode=SetMode.union):
        # Note: no need to wrap uids as UID, since all calls are public functions, and no access to dict is done.
        relation_uid = self.add_relation(name, semantic_type, uid=relation_uid, ont_uid=ont_uid,
                                         frame_value=frame_value, set_mode=set_mode)
        self.add_rdf(relation_uid=relation_uid, rdf_type=RDF.subject,
                     element_uid=object_uid_1, element_type=ElementType.object)
        self.add_rdf(relation_uid=relation_uid, rdf_type=RDF.object,
                     element_uid=object_uid_2, element_type=ElementType.object)

        return relation_uid

    def add_relation_action_object(self, name, semantic_type, action_uid, object_uid, relation_uid=None,
                                   ont_uid=None, frame_value=None, set_mode=SetMode.union):
        # Note: no need to wrap uids as UID, since all calls are public functions, and no access to dict is done.
        relation_uid = self.add_relation(name, semantic_type, uid=relation_uid, ont_uid=ont_uid,
                                         frame_value=frame_value, set_mode=set_mode)
        self.add_rdf(relation_uid=relation_uid, rdf_type=RDF.subject,
                     element_uid=action_uid, element_type=ElementType.action)
        self.add_rdf(relation_uid=relation_uid, rdf_type=RDF.object,
                     element_uid=object_uid, element_type=ElementType.object)

        return relation_uid

    def add_relation_subject_object(self, name, semantic_type, subject_type, subject_uid, object_type, object_uid,
                                    relation_uid=None, ont_uid=None, frame_value=None, set_mode=SetMode.union):
        # Note: no need to wrap uids as UID, since all calls are public functions, and no access to dict is done.
        relation_uid = self.add_relation(name, semantic_type, uid=relation_uid, ont_uid=ont_uid,
                                         frame_value=frame_value, set_mode=set_mode)
        assert(isinstance(subject_type, ElementType))
        assert(isinstance(object_type, ElementType))
        self.add_rdf(relation_uid=relation_uid, rdf_type=RDF.subject,
                     element_uid=subject_uid, element_type=subject_type)
        self.add_rdf(relation_uid=relation_uid, rdf_type=RDF.object,
                     element_uid=object_uid, element_type=object_type)

        return relation_uid

    def add_object_data(self, uid, object_data, frame_value=None, set_mode=SetMode.union):
        return self.__set_element_data(ElementType.object, UID(uid), object_data, FrameIntervals(frame_value),
                                       set_mode)

    def add_action_data(self, uid, action_data, frame_value=None, set_mode=SetMode.union):
        return self.__set_element_data(ElementType.action, UID(uid), action_data, FrameIntervals(frame_value),
                                       set_mode)

    def add_event_data(self, uid, event_data, frame_value=None, set_mode=SetMode.union):
        return self.__set_element_data(ElementType.evevt, UID(uid), event_data, FrameIntervals(frame_value),
                                       set_mode)

    def add_context_data(self, uid, context_data, frame_value=None, set_mode=SetMode.union):
        return self.__set_element_data(ElementType.context, UID(uid), context_data, FrameIntervals(frame_value),
                                       set_mode)
    
    def add_element_data(self, element_type, uid, element_data, frame_value=None, set_mode=SetMode.union):
        return self.__set_element_data(element_type, UID(uid), element_data, FrameIntervals(frame_value),
                                       set_mode)

    ##################################################
    # Get / Read
    ##################################################
    def get_data(self):
        return self.data

    def has_elements(self, element_type):
        element_type_name = element_type.name
        return element_type_name + &#39;s&#39; in self.data[&#39;vcd&#39;]

    def has_objects(self):
        return &#39;objects&#39; in self.data[&#39;vcd&#39;]

    def has_actions(self):
        return &#39;actions&#39; in self.data[&#39;vcd&#39;]

    def has_contexts(self):
        return &#39;contexts&#39; in self.data[&#39;vcd&#39;]

    def has_events(self):
        return &#39;events&#39; in self.data[&#39;vcd&#39;]

    def has_relations(self):
        return &#39;relations&#39; in self.data[&#39;vcd&#39;]

    def has(self, element_type, uid):
        if not element_type.name + &#39;s&#39; in self.data[&#39;vcd&#39;]:
            return False
        else:
            uid_str = UID(uid).as_str()
            if uid_str in self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;]:
                return True
            else:
                return False

    def has_element_data(self, element_type, uid, element_data):
        if not self.has(element_type, uid):
            return False
        else:
            uid_str = UID(uid).as_str()
            if element_type.name + &#39;_data_pointers&#39; not in self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;][uid_str]:
                return False
            name = element_data.data[&#39;name&#39;]
            return name in self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;][uid_str][element_type.name + &#39;_data_pointers&#39;]

    def has_frame(self, frame_num):
        if &#39;frames&#39; not in self.data[&#39;vcd&#39;]:
            return False
        else:
            if frame_num in self.data[&#39;vcd&#39;][&#39;frames&#39;]:
                return True
            else:
                return False

    def get_all(self, element_type):
        &#34;&#34;&#34;
        Returns all elements of the specified ElementType.
        e.g. all Object&#39;s or Context&#39;s
        &#34;&#34;&#34;
        assert(isinstance(element_type, ElementType))
        return self.data[&#39;vcd&#39;].get(element_type.name + &#39;s&#39;)

    def get_element(self, element_type, uid):
        assert (isinstance(element_type, ElementType))
        if self.data[&#39;vcd&#39;].get(element_type.name + &#39;s&#39;) is None:
            warnings.warn(&#34;WARNING: trying to get a &#34; + element_type.name + &#34; but this VCD has none.&#34;)
            return None
        uid_str = UID(uid).as_str()
        if uid_str in self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;]:
            return self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;][uid_str]
        else:
            warnings.warn(&#34;WARNING: trying to get non-existing &#34; + element_type.name + &#34; with uid: &#34; + uid_str)
            return None

    def get_object(self, uid):
        return self.get_element(ElementType.object, uid)

    def get_action(self, uid):
        return self.get_element(ElementType.action, uid)

    def get_event(self, uid):
        return self.get_element(ElementType.event, uid)

    def get_context(self, uid):
        return self.get_element(ElementType.context, uid)

    def get_relation(self, uid):
        return self.get_element(ElementType.relation, uid)

    def get_element_uid_by_name(self, element_type, name):
        assert (self.has_elements(element_type))
        element_type_name = element_type.name
        elements = self.data[&#39;vcd&#39;][element_type_name + &#39;s&#39;]
        for uid, element in elements.items():
            name_element = element[&#39;name&#39;]
            if name_element == name:
                return uid
        return None

    def get_object_uid_by_name(self, name):
        return self.get_element_uid_by_name(ElementType.object, name)

    def get_action_uid_by_name(self, name):
        return self.get_element_uid_by_name(ElementType.action, name)

    def get_context_uid_by_name(self, name):
        return self.get_element_uid_by_name(ElementType.context, name)

    def get_event_uid_by_name(self, name):
        return self.get_element_uid_by_name(ElementType.event, name)

    def get_relation_uid_by_name(self, name):
        return self.get_element_uid_by_name(ElementType.relation, name)

    def get_frame(self, frame_num):
        if &#39;frames&#39; not in self.data[&#39;vcd&#39;]:
            return None
        else:
            frame = self.data[&#39;vcd&#39;][&#39;frames&#39;].get(frame_num)
            return frame

    def get_elements_of_type(self, element_type, semantic_type):
        uids_str = []
        if not element_type.name + &#39;s&#39; in self.data[&#39;vcd&#39;]:
            return uids_str
        for uid_str, element in self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;].items():
            if element[&#39;type&#39;] == semantic_type:
                uids_str.append(uid_str)
        return uids_str

    def get_elements_with_element_data_name(self, element_type, data_name):
        uids_str = []
        for uid_str in self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;]:
            element = self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;][uid_str]
            if element_type.name + &#39;_data_pointers&#39; in element:
                for name in element[element_type.name + &#39;_data_pointers&#39;]:
                    if name == data_name:
                        uids_str.append(uid_str)
                        break
        return uids_str

    def get_objects_with_object_data_name(self, data_name):
        return self.get_elements_with_element_data_name(ElementType.object, data_name)

    def get_actions_with_action_data_name(self, data_name):
        return self.get_elements_with_element_data_name(ElementType.action, data_name)

    def get_events_with_event_data_name(self, data_name):
        return self.get_elements_with_element_data_name(ElementType.event, data_name)

    def get_contexts_with_context_data_name(self, data_name):
        return self.get_elements_with_element_data_name(ElementType.context, data_name)

    def get_frames_with_element_data_name(self, element_type, uid, data_name):
        uid_str = UID(uid).as_str()
        if uid_str in self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;]:
            element = self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;][uid_str]
            if element_type.name + &#39;_data_pointers&#39; in element:
                for name in element[element_type.name + &#39;_data_pointers&#39;]:
                    if name == data_name:
                        return FrameIntervals(element[element_type.name + &#39;_data_pointers&#39;][name][&#39;frame_intervals&#39;])
        return None

    def get_frames_with_object_data_name(self, uid, data_name):
        return self.get_frames_with_element_data_name(ElementType.object, uid, data_name)

    def get_frames_with_action_data_name(self, uid, data_name):
        return self.get_frames_with_element_data_name(ElementType.action, uid, data_name)

    def get_frames_with_event_data_name(self, uid, data_name):
        return self.get_frames_with_element_data_name(ElementType.event, uid, data_name)

    def get_frames_with_context_data_name(self, uid, data_name):
        return self.get_frames_with_element_data_name(ElementType.context, uid, data_name)

    def get_element_data_count_per_type(self, element_type, uid, data_type, frame_num=None):
        # Returns 0 if no such element exist or if the element does not have the data_type
        # Returns the count otherwise (e.g. how many &#34;bbox&#34; does this object have)
        assert(isinstance(data_type, types.ObjectDataType))
        uid_str = UID(uid).as_str()
        if self.has(element_type, uid):
            if frame_num is not None:
                # Dynamic info
                if not isinstance(frame_num, int):
                    warnings.warn(&#34;WARNING: Calling get_element_data with a non-integer frame_num.&#34;)
                frame = self.get_frame(frame_num)
                if frame is not None:
                    if element_type.name + &#39;s&#39; in frame:
                        if uid_str in frame[element_type.name + &#39;s&#39;]:
                            element = frame[element_type.name + &#39;s&#39;][uid_str]
                            for prop in element[element_type.name + &#39;_data&#39;]:
                                if prop == data_type.name:
                                    return len(element[element_type.name + &#39;_data&#39;][prop])
                        else:
                            return 0
                    else:
                        return 0
            else:
                # Static info
                element = self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;][uid_str]
                for prop in element[element_type.name + &#39;_data&#39;]:
                    if prop == data_type.name:
                        return len(element[element_type.name + &#39;_data&#39;][prop])
        else:
            return 0
        return 0

    def get_element_data(self, element_type, uid, data_name, frame_num=None):
        element_exists = self.has(element_type, uid)
        vcd_has_frames = not self.get_frame_intervals().empty()

        if not element_exists:  # the element does not exist
            return None

        if not vcd_has_frames and frame_num is not None:  # don&#39;t ask for frame-specific info in a VCD without frames
            return None

        frame_num_is_number = isinstance(frame_num, int)
        uid_str = UID(uid).as_str()

        element_exists_in_this_frame = False
        if frame_num is not None and frame_num_is_number:
            # The user is asking for frame-specific attributes

            found_in_frame = False
            frame = self.get_frame(frame_num)
            if frame is not None:
                if element_type.name + &#39;s&#39; in frame:
                    if uid_str in frame[element_type.name + &#39;s&#39;]:
                        element_exists_in_this_frame = True
                        element = frame[element_type.name + &#39;s&#39;][uid_str]
                        if element_type.name + &#39;_data&#39; in element:
                            for prop in element[element_type.name + &#39;_data&#39;]:
                                val_array = element[element_type.name + &#39;_data&#39;][prop]
                                for val in val_array:
                                    if val[&#39;name&#39;] == data_name:
                                        return val
            if not found_in_frame:
                # The user has asked to get an element_data for a certain frame, but there is no info about this
                # element or element_data at this frame
                if not element_exists_in_this_frame:
                    return None
                element = self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;][uid_str]  # the element exists because of prev. ctrl
                for prop in element[element_type.name + &#39;_data&#39;]:
                    val_array = element[element_type.name + &#39;_data&#39;][prop]
                    for val in val_array:
                        if val[&#39;name&#39;] == data_name:
                            return val
        else:
            # The user is asking for static attributes at the root of the element
            element = self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;][uid_str]  # the element exists because of prev. ctrl
            for prop in element[element_type.name + &#39;_data&#39;]:
                val_array = element[element_type.name + &#39;_data&#39;][prop]
                for val in val_array:
                    if val[&#39;name&#39;] == data_name:
                        return val
        return None

    def get_object_data(self, uid, data_name, frame_num=None):
        return self.get_element_data(ElementType.object, uid, data_name, frame_num)

    def get_action_data(self, uid, data_name, frame_num=None):
        return self.get_element_data(ElementType.action, uid, data_name, frame_num)

    def get_event_data(self, uid, data_name, frame_num=None):
        return self.get_element_data(ElementType.event, uid, data_name, frame_num)

    def get_context_data(self, uid, data_name, frame_num=None):
        return self.get_element_data(ElementType.context, uid, data_name, frame_num)

    def get_element_data_pointer(self, element_type, uid, data_name):
        uid_str = UID(uid).as_str()
        if self.has(element_type, uid):
            if element_type.name + &#39;s&#39; in self.data[&#39;vcd&#39;]:
                if uid_str in self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;]:
                    element = self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;][uid_str]
                    if element_type.name + &#39;_data_pointers&#39; in element:
                        if data_name in element[element_type.name + &#39;_data_pointers&#39;]:
                            return element[element_type.name + &#39;_data_pointers&#39;][data_name]
        else:
            warnings.warn(&#34;WARNING: Asking element data from a non-existing Element.&#34;)
        return None

    def get_element_data_frame_intervals(self, element_type, uid, data_name):
        return FrameIntervals(self.get_element_data_pointer(element_type, uid, data_name)[&#39;frame_intervals&#39;])

    def get_object_data_frame_intervals(self, uid, data_name):
        return self.get_element_data_frame_intervals(ElementType.object, uid, data_name)

    def get_action_data_frame_intervals(self, uid, data_name):
        return self.get_element_data_frame_intervals(ElementType.action, uid, data_name)

    def get_event_data_frame_intervals(self, uid, data_name):
        return self.get_element_data_frame_intervals(ElementType.event, uid, data_name)

    def get_context_data_frame_intervals(self, uid, data_name):
        return self.get_element_data_frame_intervals(ElementType.context, uid, data_name)

    def get_num_elements(self, element_type):
        if self.has_elements(element_type):
            return len(self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;])
        else:
            return 0

    def get_num_objects(self):
        return self.get_num_elements(ElementType.object)

    def get_num_actions(self):
        return self.get_num_elements(ElementType.action)

    def get_num_events(self):
        return self.get_num_elements(ElementType.event)

    def get_num_contexts(self):
        return self.get_num_elements(ElementType.context)

    def get_num_relations(self):
        return self.get_num_elements(ElementType.relation)

    def get_elements_uids(self, element_type: ElementType):
        if self.has_elements(element_type):
            list_of_uids = list(self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;].keys())
            return list_of_uids
        else:
            return []

    def get_ontology(self, ont_uid):
        ont_uid_str = UID(ont_uid).as_str()
        if &#39;ontologies&#39; in self.data[&#39;vcd&#39;]:
            if ont_uid_str in self.data[&#39;vcd&#39;][&#39;ontologies&#39;]:
                return copy.deepcopy(self.data[&#39;vcd&#39;][&#39;ontologies&#39;][ont_uid_str])
        return None

    def get_metadata(self):
        if &#39;metadata&#39; in self.data[&#39;vcd&#39;]:
            return self.data[&#39;vcd&#39;][&#39;metadata&#39;]
        else:
            return dict()

    def has_coordinate_system(self, cs):
        if &#39;coordinate_systems&#39; in self.data[&#39;vcd&#39;]:
            if cs in self.data[&#39;vcd&#39;][&#39;coordinate_systems&#39;]:
                return True
        return False

    def get_coordinate_systems(self):
        if &#39;coordinate_systems&#39; in self.data[&#39;vcd&#39;]:
            return copy.deepcopy(self.data[&#39;vcd&#39;][&#39;coordinate_systems&#39;])
        else:
            return []

    def get_coordinate_system(self, coordinate_system):
        if self.has_coordinate_system(coordinate_system):
            return copy.deepcopy(self.data[&#39;vcd&#39;][&#39;coordinate_systems&#39;][coordinate_system])
        else:
            return None

    def has_stream(self, stream_name):
        if &#39;streams&#39; in self.data[&#39;vcd&#39;]:
            if stream_name in self.data[&#39;vcd&#39;][&#39;streams&#39;]:
                return True
            else:
                return False

    def get_streams(self):
        if &#39;streams&#39; in self.data[&#39;vcd&#39;]:
            return copy.deepcopy(self.data[&#39;vcd&#39;][&#39;streams&#39;])
        else:
            return {}

    def get_stream(self, stream_name):
        if self.has_stream(stream_name):
            return copy.deepcopy(self.data[&#39;vcd&#39;][&#39;streams&#39;][stream_name])
        else:
            return None

    def get_frame_intervals(self):
        if &#39;frame_intervals&#39; in self.data[&#39;vcd&#39;]:
            return FrameIntervals(self.data[&#39;vcd&#39;][&#39;frame_intervals&#39;])
        else:
            return FrameIntervals()

    def get_element_frame_intervals(self, element_type, uid):
        uid_str = UID(uid).as_str()
        if not element_type.name + &#39;s&#39; in self.data[&#39;vcd&#39;]:
            return FrameIntervals()
        else:
            if not uid_str in self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;]:
                return FrameIntervals()
            return FrameIntervals(self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;][uid_str].get(&#39;frame_intervals&#39;))

    def relation_has_frame_intervals(self, relation_uid):
        rel_uid = UID(relation_uid)
        relation = self.get_relation(relation_uid)
        if relation is None:
            warnings.warn(&#34;WARNING: Non-existing relation &#34; + rel_uid.as_str())
        else:
            if &#39;frame_intervals&#39; not in relation:
                return False
            else:
                if len(relation[&#39;frame_intervals&#39;]) == 0:
                    return False
                else:
                    return True

    ##################################################
    # Remove
    ##################################################
    def rm_element_by_type(self, element_type, semantic_type):
        elements = self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;]

        # Get Element from summary
        uids_to_remove_str = []
        for uid_str, element in elements.items():
            if element[&#39;type&#39;] == semantic_type:
                uids_to_remove_str.append(uid_str)
        for uid_str in uids_to_remove_str:
            self.rm_element(element_type, uid_str)

    def rm_object_by_type(self, semantic_type):
        self.rm_element_by_type(ElementType.object, semantic_type)

    def rm_action_by_type(self, semantic_type):
        self.rm_element_by_type(ElementType.action, semantic_type)

    def rm_event_by_type(self, semantic_type):
        self.rm_element_by_type(ElementType.event, semantic_type)

    def rm_context_by_type(self, semantic_type):
        self.rm_element_by_type(ElementType.context, semantic_type)

    def rm_relation_by_type(self, semantic_type):
        self.rm_element_by_type(ElementType.relation, semantic_type)

    def rm_element(self, element_type, uid):
        uid_str = UID(uid).as_str()
        if not self.has_elements(element_type):
            return

        # Get element from summary
        if not self.has(element_type, uid):
            return

        # Remove from frames: let&#39;s read frame_intervals from summary
        elements = self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;]
        element = elements[uid_str]
        if &#39;frame_intervals&#39; in element:
            for i in range(0, len(element[&#39;frame_intervals&#39;])):
                fi = element[&#39;frame_intervals&#39;][i]
                for frame_num in range(fi[&#39;frame_start&#39;], fi[&#39;frame_end&#39;]+1):
                    elements_in_frame = self.data[&#39;vcd&#39;][&#39;frames&#39;][frame_num][element_type.name + &#39;s&#39;]
                    if uid in elements_in_frame:
                        del elements_in_frame[uid_str]
                    if len(elements_in_frame) == 0:  # objects might have end up empty TODO: test this
                        del self.data[&#39;vcd&#39;][&#39;frames&#39;][frame_num][element_type.name + &#39;s&#39;]
                        if len(self.data[&#39;vcd&#39;][&#39;frames&#39;][frame_num]) == 0:  # this frame may have ended up being empty
                            del self.data[&#39;vcd&#39;][&#39;frames&#39;][frame_num]
                            self.__rm_frame(frame_num)

        # Delete this element from summary
        del elements[uid_str]
        if len(elements) == 0:
            del self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;]

    def rm_object(self, uid):
        self.rm_element(ElementType.object, uid)

    def rm_action(self, uid):
        self.rm_element(ElementType.action, uid)

    def rm_event(self, uid):
        self.rm_element(ElementType.event, uid)

    def rm_context(self, uid):
        self.rm_element(ElementType.context, uid)

    def rm_relation(self, uid):
        self.rm_element(ElementType.relation, uid)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="vcd.core.VCD.add_action"><code class="name flex">
<span>def <span class="ident">add_action</span></span>(<span>self, name, semantic_type='', frame_value=None, uid=None, ont_uid=None, coordinate_system=None, set_mode=SetMode.union)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_action(self, name, semantic_type=&#39;&#39;, frame_value=None, uid=None, ont_uid=None, coordinate_system=None,
               set_mode=SetMode.union):
    return self.__set_element(ElementType.action, name, semantic_type, FrameIntervals(frame_value),
                              UID(uid), UID(ont_uid), coordinate_system, set_mode).as_str()</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.add_action_data"><code class="name flex">
<span>def <span class="ident">add_action_data</span></span>(<span>self, uid, action_data, frame_value=None, set_mode=SetMode.union)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_action_data(self, uid, action_data, frame_value=None, set_mode=SetMode.union):
    return self.__set_element_data(ElementType.action, UID(uid), action_data, FrameIntervals(frame_value),
                                   set_mode)</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.add_annotator"><code class="name flex">
<span>def <span class="ident">add_annotator</span></span>(<span>self, annotator)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_annotator(self, annotator):
    assert(type(annotator) is str)
    if &#39;metadata&#39; not in self.data[&#39;vcd&#39;]:
        self.data[&#39;vcd&#39;][&#39;metadata&#39;] = {}
    self.data[&#39;vcd&#39;][&#39;metadata&#39;][&#39;annotator&#39;] = annotator</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.add_comment"><code class="name flex">
<span>def <span class="ident">add_comment</span></span>(<span>self, comment)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_comment(self, comment):
    assert(type(comment) is str)
    if &#39;metadata&#39; not in self.data[&#39;vcd&#39;]:
        self.data[&#39;vcd&#39;][&#39;metadata&#39;] = {}
    self.data[&#39;vcd&#39;][&#39;metadata&#39;][&#39;comment&#39;] = comment</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.add_context"><code class="name flex">
<span>def <span class="ident">add_context</span></span>(<span>self, name, semantic_type='', frame_value=None, uid=None, ont_uid=None, coordinate_system=None, set_mode=SetMode.union)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_context(self, name, semantic_type=&#39;&#39;, frame_value=None, uid=None, ont_uid=None, coordinate_system=None,
                set_mode=SetMode.union):
    return self.__set_element(ElementType.context, name, semantic_type, FrameIntervals(frame_value),
                              UID(uid), UID(ont_uid), coordinate_system, set_mode).as_str()</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.add_context_data"><code class="name flex">
<span>def <span class="ident">add_context_data</span></span>(<span>self, uid, context_data, frame_value=None, set_mode=SetMode.union)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_context_data(self, uid, context_data, frame_value=None, set_mode=SetMode.union):
    return self.__set_element_data(ElementType.context, UID(uid), context_data, FrameIntervals(frame_value),
                                   set_mode)</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.add_coordinate_system"><code class="name flex">
<span>def <span class="ident">add_coordinate_system</span></span>(<span>self, name, cs_type, parent_name='', pose_wrt_parent=[], uid=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_coordinate_system(self, name, cs_type, parent_name=&#34;&#34;, pose_wrt_parent=[], uid=None):
    assert(isinstance(cs_type, types.CoordinateSystemType))
    # Create entry
    self.data[&#39;vcd&#39;].setdefault(&#39;coordinate_systems&#39;, {})
    self.data[&#39;vcd&#39;][&#39;coordinate_systems&#39;][name] = {&#39;type&#39;: cs_type.name,
                                                    &#39;parent&#39;: parent_name,
                                                    &#39;pose_wrt_parent&#39;: pose_wrt_parent,
                                                    &#39;children&#39;: []}
    if uid is not None:
        assert(isinstance(uid, str))
        self.data[&#39;vcd&#39;][&#39;coordinate_systems&#39;][name].update({&#34;uid&#34;: uid})

    # Update parents
    if parent_name != &#34;&#34;:
        found = False
        for n, cs in self.data[&#39;vcd&#39;][&#39;coordinate_systems&#39;].items():
            if n == parent_name:
                found = True
                cs[&#39;children&#39;].append(name)
        if not found:
            warnings.warn(&#34;WARNING: Creating a coordinate system with a non-defined parent coordinate system.&#34;
                          &#34;Coordinate systems must be introduced in order&#34;)</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.add_element"><code class="name flex">
<span>def <span class="ident">add_element</span></span>(<span>self, element_type, name, semantic_type='', frame_value=None, uid=None, ont_uid=None, coordinate_system=None, set_mode=SetMode.union)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_element(self, element_type, name, semantic_type=&#39;&#39;, frame_value=None, uid=None, ont_uid=None, coordinate_system=None,
                set_mode=SetMode.union):
    return self.__set_element(element_type, name, semantic_type, FrameIntervals(frame_value),
                              UID(uid), UID(ont_uid), coordinate_system, set_mode).as_str()</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.add_element_data"><code class="name flex">
<span>def <span class="ident">add_element_data</span></span>(<span>self, element_type, uid, element_data, frame_value=None, set_mode=SetMode.union)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_element_data(self, element_type, uid, element_data, frame_value=None, set_mode=SetMode.union):
    return self.__set_element_data(element_type, UID(uid), element_data, FrameIntervals(frame_value),
                                   set_mode)</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.add_event"><code class="name flex">
<span>def <span class="ident">add_event</span></span>(<span>self, name, semantic_type='', frame_value=None, uid=None, ont_uid=None, coordinate_system=None, set_mode=SetMode.union)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_event(self, name, semantic_type=&#39;&#39;, frame_value=None, uid=None, ont_uid=None, coordinate_system=None,
              set_mode=SetMode.union):
    return self.__set_element(ElementType.event, name, semantic_type, FrameIntervals(frame_value),
                              UID(uid), UID(ont_uid), coordinate_system, set_mode).as_str()</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.add_event_data"><code class="name flex">
<span>def <span class="ident">add_event_data</span></span>(<span>self, uid, event_data, frame_value=None, set_mode=SetMode.union)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_event_data(self, uid, event_data, frame_value=None, set_mode=SetMode.union):
    return self.__set_element_data(ElementType.evevt, UID(uid), event_data, FrameIntervals(frame_value),
                                   set_mode)</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.add_file_version"><code class="name flex">
<span>def <span class="ident">add_file_version</span></span>(<span>self, version)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_file_version(self, version):
    assert (type(version) is str)
    if &#39;metadata&#39; not in self.data[&#39;vcd&#39;]:
        self.data[&#39;vcd&#39;][&#39;metadata&#39;] = {}
    self.data[&#39;vcd&#39;][&#39;metadata&#39;][&#39;file_version&#39;] = version</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.add_frame_properties"><code class="name flex">
<span>def <span class="ident">add_frame_properties</span></span>(<span>self, frame_num, timestamp=None, properties=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_frame_properties(self, frame_num, timestamp=None, properties=None):
    self.__add_frame(frame_num)  # this function internally checks if the frame already exists
    self.data[&#39;vcd&#39;][&#39;frames&#39;][frame_num].setdefault(&#39;frame_properties&#39;, dict())
    if timestamp is not None:
        assert (isinstance(timestamp, str))
        self.data[&#39;vcd&#39;][&#39;frames&#39;][frame_num][&#39;frame_properties&#39;][&#39;timestamp&#39;] = timestamp

    if properties is not None:
        assert (isinstance(properties, dict))
        self.data[&#39;vcd&#39;][&#39;frames&#39;][frame_num][&#39;frame_properties&#39;].update(properties)</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.add_metadata_properties"><code class="name flex">
<span>def <span class="ident">add_metadata_properties</span></span>(<span>self, properties)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_metadata_properties(self, properties):
    assert(isinstance(properties, dict))
    prop = self.data[&#39;vcd&#39;][&#39;metadata&#39;]
    prop.update(properties)</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.add_name"><code class="name flex">
<span>def <span class="ident">add_name</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_name(self, name):
    assert(type(name) is str)
    if &#39;metadata&#39; not in self.data[&#39;vcd&#39;]:
        self.data[&#39;vcd&#39;][&#39;metadata&#39;] = {}
    self.data[&#39;vcd&#39;][&#39;metadata&#39;][&#39;name&#39;] = name</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.add_object"><code class="name flex">
<span>def <span class="ident">add_object</span></span>(<span>self, name, semantic_type='', frame_value=None, uid=None, ont_uid=None, coordinate_system=None, set_mode=SetMode.union)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_object(self, name, semantic_type=&#39;&#39;, frame_value=None, uid=None, ont_uid=None, coordinate_system=None,
               set_mode=SetMode.union):
    return self.__set_element(ElementType.object, name, semantic_type, FrameIntervals(frame_value),
                              UID(uid), UID(ont_uid), coordinate_system, set_mode).as_str()</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.add_object_data"><code class="name flex">
<span>def <span class="ident">add_object_data</span></span>(<span>self, uid, object_data, frame_value=None, set_mode=SetMode.union)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_object_data(self, uid, object_data, frame_value=None, set_mode=SetMode.union):
    return self.__set_element_data(ElementType.object, UID(uid), object_data, FrameIntervals(frame_value),
                                   set_mode)</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.add_ontology"><code class="name flex">
<span>def <span class="ident">add_ontology</span></span>(<span>self, ontology_name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_ontology(self, ontology_name):
    self.data[&#39;vcd&#39;].setdefault(&#39;ontologies&#39;, dict())
    for ont_uid in self.data[&#39;vcd&#39;][&#39;ontologies&#39;]:
        if self.data[&#39;vcd&#39;][&#39;ontologies&#39;][ont_uid] == ontology_name:
            warnings.warn(&#39;WARNING: adding an already existing ontology&#39;)
            return None
    length = len(self.data[&#39;vcd&#39;][&#39;ontologies&#39;])
    self.data[&#39;vcd&#39;][&#39;ontologies&#39;][str(length)] = ontology_name
    return str(length)</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.add_rdf"><code class="name flex">
<span>def <span class="ident">add_rdf</span></span>(<span>self, relation_uid, rdf_type, element_uid, element_type)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_rdf(self, relation_uid, rdf_type, element_uid, element_type):
    assert(isinstance(element_type, ElementType))
    assert(isinstance(rdf_type, RDF))
    rel_uid = UID(relation_uid)
    el_uid = UID(element_uid)
    if rel_uid.as_str() not in self.data[&#39;vcd&#39;][&#39;relations&#39;]:
        warnings.warn(&#34;WARNING: trying to add RDF to non-existing Relation.&#34;)
        return
    else:
        relation = self.data[&#39;vcd&#39;][&#39;relations&#39;][rel_uid.as_str()]
        if el_uid.as_str() not in self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;]:
            warnings.warn(&#34;WARNING: trying to add RDF using non-existing Element.&#34;)
            return
        else:
            if rdf_type == RDF.subject:
                relation.setdefault(&#39;rdf_subjects&#39;, [])
                relation[&#39;rdf_subjects&#39;].append(
                    {&#39;uid&#39;: el_uid.as_str(), &#39;type&#39;: element_type.name}
                )
            else:
                relation.setdefault(&#39;rdf_objects&#39;, [])
                relation[&#39;rdf_objects&#39;].append(
                    {&#39;uid&#39;: el_uid.as_str(), &#39;type&#39;: element_type.name}
                )</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.add_relation"><code class="name flex">
<span>def <span class="ident">add_relation</span></span>(<span>self, name, semantic_type='', frame_value=None, uid=None, ont_uid=None, set_mode=SetMode.union)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_relation(self, name, semantic_type=&#39;&#39;, frame_value=None, uid=None, ont_uid=None,
                 set_mode=SetMode.union):
    if set_mode == SetMode.replace and uid is not None:
        if self.has(ElementType.relation, uid):
            relation = self.data[&#39;vcd&#39;][&#39;relations&#39;][UID(uid).as_str()]
            relation[&#39;rdf_subjects&#39;] = []
            relation[&#39;rdf_objects&#39;] = []

    relation_uid = self.__set_element(
        ElementType.relation, name, semantic_type, frame_intervals=FrameIntervals(frame_value),
        uid=UID(uid), ont_uid=UID(ont_uid), set_mode=set_mode, coordinate_system=None)
    return relation_uid.as_str()</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.add_relation_action_action"><code class="name flex">
<span>def <span class="ident">add_relation_action_action</span></span>(<span>self, name, semantic_type, action_uid_1, action_uid_2, relation_uid=None, ont_uid=None, frame_value=None, set_mode=SetMode.union)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_relation_action_action(self, name, semantic_type, action_uid_1, action_uid_2, relation_uid=None,
                               ont_uid=None, frame_value=None, set_mode=SetMode.union):
    # Note: no need to wrap uids as UID, since all calls are public functions, and no access to dict is done.
    relation_uid = self.add_relation(name, semantic_type, uid=relation_uid, ont_uid=ont_uid,
                                     frame_value=frame_value, set_mode=set_mode)
    self.add_rdf(relation_uid=relation_uid, rdf_type=RDF.subject,
                 element_uid=action_uid_1, element_type=ElementType.action)
    self.add_rdf(relation_uid=relation_uid, rdf_type=RDF.object,
                 element_uid=action_uid_2, element_type=ElementType.action)

    return relation_uid</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.add_relation_action_object"><code class="name flex">
<span>def <span class="ident">add_relation_action_object</span></span>(<span>self, name, semantic_type, action_uid, object_uid, relation_uid=None, ont_uid=None, frame_value=None, set_mode=SetMode.union)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_relation_action_object(self, name, semantic_type, action_uid, object_uid, relation_uid=None,
                               ont_uid=None, frame_value=None, set_mode=SetMode.union):
    # Note: no need to wrap uids as UID, since all calls are public functions, and no access to dict is done.
    relation_uid = self.add_relation(name, semantic_type, uid=relation_uid, ont_uid=ont_uid,
                                     frame_value=frame_value, set_mode=set_mode)
    self.add_rdf(relation_uid=relation_uid, rdf_type=RDF.subject,
                 element_uid=action_uid, element_type=ElementType.action)
    self.add_rdf(relation_uid=relation_uid, rdf_type=RDF.object,
                 element_uid=object_uid, element_type=ElementType.object)

    return relation_uid</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.add_relation_object_action"><code class="name flex">
<span>def <span class="ident">add_relation_object_action</span></span>(<span>self, name, semantic_type, object_uid, action_uid, relation_uid=None, ont_uid=None, frame_value=None, set_mode=SetMode.union)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_relation_object_action(self, name, semantic_type, object_uid, action_uid, relation_uid=None,
                               ont_uid=None, frame_value=None, set_mode=SetMode.union):
    # Note: no need to wrap uids as UID, since all calls are public functions, and no access to dict is done.
    relation_uid = self.add_relation(name, semantic_type, uid=relation_uid, ont_uid=ont_uid,
                                     frame_value=frame_value, set_mode=set_mode)
    self.add_rdf(relation_uid=relation_uid, rdf_type=RDF.subject,
                 element_uid=object_uid, element_type=ElementType.object)
    self.add_rdf(relation_uid=relation_uid, rdf_type=RDF.object,
                 element_uid=action_uid, element_type=ElementType.action)

    return relation_uid</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.add_relation_object_object"><code class="name flex">
<span>def <span class="ident">add_relation_object_object</span></span>(<span>self, name, semantic_type, object_uid_1, object_uid_2, relation_uid=None, ont_uid=None, frame_value=None, set_mode=SetMode.union)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_relation_object_object(self, name, semantic_type, object_uid_1, object_uid_2, relation_uid=None,
                               ont_uid=None, frame_value=None, set_mode=SetMode.union):
    # Note: no need to wrap uids as UID, since all calls are public functions, and no access to dict is done.
    relation_uid = self.add_relation(name, semantic_type, uid=relation_uid, ont_uid=ont_uid,
                                     frame_value=frame_value, set_mode=set_mode)
    self.add_rdf(relation_uid=relation_uid, rdf_type=RDF.subject,
                 element_uid=object_uid_1, element_type=ElementType.object)
    self.add_rdf(relation_uid=relation_uid, rdf_type=RDF.object,
                 element_uid=object_uid_2, element_type=ElementType.object)

    return relation_uid</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.add_relation_subject_object"><code class="name flex">
<span>def <span class="ident">add_relation_subject_object</span></span>(<span>self, name, semantic_type, subject_type, subject_uid, object_type, object_uid, relation_uid=None, ont_uid=None, frame_value=None, set_mode=SetMode.union)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_relation_subject_object(self, name, semantic_type, subject_type, subject_uid, object_type, object_uid,
                                relation_uid=None, ont_uid=None, frame_value=None, set_mode=SetMode.union):
    # Note: no need to wrap uids as UID, since all calls are public functions, and no access to dict is done.
    relation_uid = self.add_relation(name, semantic_type, uid=relation_uid, ont_uid=ont_uid,
                                     frame_value=frame_value, set_mode=set_mode)
    assert(isinstance(subject_type, ElementType))
    assert(isinstance(object_type, ElementType))
    self.add_rdf(relation_uid=relation_uid, rdf_type=RDF.subject,
                 element_uid=subject_uid, element_type=subject_type)
    self.add_rdf(relation_uid=relation_uid, rdf_type=RDF.object,
                 element_uid=object_uid, element_type=object_type)

    return relation_uid</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.add_stream"><code class="name flex">
<span>def <span class="ident">add_stream</span></span>(<span>self, stream_name, uri, description, stream_type)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_stream(self, stream_name, uri, description, stream_type):
    assert(isinstance(stream_name, str))
    assert(isinstance(uri, str))
    assert(isinstance(description, str))

    self.data[&#39;vcd&#39;].setdefault(&#39;streams&#39;, dict())
    self.data[&#39;vcd&#39;][&#39;streams&#39;].setdefault(stream_name, dict())
    if isinstance(stream_type, StreamType):
        self.data[&#39;vcd&#39;][&#39;streams&#39;][stream_name] = {
            &#39;description&#39;: description, &#39;uri&#39;: uri, &#39;type&#39;: stream_type.name
        }
    elif isinstance(stream_type, str):
        self.data[&#39;vcd&#39;][&#39;streams&#39;][stream_name] = {
            &#39;description&#39;: description, &#39;uri&#39;: uri, &#39;type&#39;: stream_type
        }</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.add_stream_properties"><code class="name flex">
<span>def <span class="ident">add_stream_properties</span></span>(<span>self, stream_name, properties=None, intrinsics=None, stream_sync=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_stream_properties(self, stream_name, properties=None, intrinsics=None, stream_sync=None):
    has_arguments = False
    if intrinsics is not None:
        assert(isinstance(intrinsics, types.Intrinsics))
        has_arguments = True
    if properties is not None:
        assert(isinstance(properties, dict))  # &#34;Properties of Stream should be defined as a dictionary&#34;
        has_arguments = True
    if stream_sync is not None:
        assert(isinstance(stream_sync, types.StreamSync))
        has_arguments = True
        if stream_sync.frame_vcd is not None:
            frame_num = stream_sync.frame_vcd
        else:
            frame_num = None
    else:
        frame_num = None

    if not has_arguments:
        return

    # This function can be used to add stream properties. If frame_num is defined, the information is embedded
    # inside &#39;frame_properties&#39; of the specified frame. Otherwise, the information is embedded into
    # &#39;stream_properties&#39; inside &#39;metadata&#39;.

    # Find if this stream is declared
    if &#39;metadata&#39; in self.data[&#39;vcd&#39;]:
        if &#39;streams&#39; in self.data[&#39;vcd&#39;]:
            if stream_name in self.data[&#39;vcd&#39;][&#39;streams&#39;]:
                if frame_num is None:
                    # This information is static
                    self.data[&#39;vcd&#39;][&#39;streams&#39;][stream_name].setdefault(&#39;stream_properties&#39;, dict())
                    if properties is not None:
                        self.data[&#39;vcd&#39;][&#39;streams&#39;][stream_name][&#39;stream_properties&#39;].\
                            update(properties)
                    if intrinsics is not None:
                        self.data[&#39;vcd&#39;][&#39;streams&#39;][stream_name][&#39;stream_properties&#39;].\
                            update(intrinsics.data)
                    if stream_sync is not None:
                        if stream_sync.data:
                            self.data[&#39;vcd&#39;][&#39;streams&#39;][stream_name][&#39;stream_properties&#39;].\
                                update(stream_sync.data)
                else:
                    # This is information of the stream for a specific frame
                    self.__add_frame(frame_num)  # to add the frame in case it does not exist
                    frame = self.data[&#39;vcd&#39;][&#39;frames&#39;][frame_num]
                    frame.setdefault(&#39;frame_properties&#39;, dict())
                    frame[&#39;frame_properties&#39;].setdefault(&#39;streams&#39;, dict())
                    frame[&#39;frame_properties&#39;][&#39;streams&#39;].setdefault(stream_name, dict())
                    frame[&#39;frame_properties&#39;][&#39;streams&#39;][stream_name].setdefault(&#39;stream_properties&#39;, dict())
                    if properties is not None:
                        frame[&#39;frame_properties&#39;][&#39;streams&#39;][stream_name][&#39;stream_properties&#39;].\
                            update(properties)
                    if intrinsics is not None:
                        frame[&#39;frame_properties&#39;][&#39;streams&#39;][stream_name][&#39;stream_properties&#39;].\
                            update(intrinsics.data)

                    if stream_sync.data:
                        frame[&#39;frame_properties&#39;][&#39;streams&#39;][stream_name][&#39;stream_properties&#39;].\
                            update(stream_sync.data)
            else:
                warnings.warn(&#39;WARNING: Trying to add stream properties for non-existing stream. &#39;
                              &#39;Use add_stream first.&#39;)</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.add_transform"><code class="name flex">
<span>def <span class="ident">add_transform</span></span>(<span>self, frame_num, transform)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_transform(self, frame_num, transform):
    assert (isinstance(frame_num, int))
    assert(isinstance(transform, types.Transform))

    self.__add_frame(frame_num)  # this function internally checks if the frame already exists
    self.data[&#39;vcd&#39;][&#39;frames&#39;][frame_num].setdefault(&#39;frame_properties&#39;, dict())
    self.data[&#39;vcd&#39;][&#39;frames&#39;][frame_num][&#39;frame_properties&#39;].setdefault(&#39;transforms&#39;, dict())
    self.data[&#39;vcd&#39;][&#39;frames&#39;][frame_num][&#39;frame_properties&#39;][&#39;transforms&#39;].update(transform.data)</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.convert_to_vcd330"><code class="name flex">
<span>def <span class="ident">convert_to_vcd330</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convert_to_vcd330(self):
    return converter.ConverterVCD430toVCD330(self.data)</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.get_action"><code class="name flex">
<span>def <span class="ident">get_action</span></span>(<span>self, uid)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_action(self, uid):
    return self.get_element(ElementType.action, uid)</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.get_action_data"><code class="name flex">
<span>def <span class="ident">get_action_data</span></span>(<span>self, uid, data_name, frame_num=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_action_data(self, uid, data_name, frame_num=None):
    return self.get_element_data(ElementType.action, uid, data_name, frame_num)</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.get_action_data_frame_intervals"><code class="name flex">
<span>def <span class="ident">get_action_data_frame_intervals</span></span>(<span>self, uid, data_name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_action_data_frame_intervals(self, uid, data_name):
    return self.get_element_data_frame_intervals(ElementType.action, uid, data_name)</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.get_action_uid_by_name"><code class="name flex">
<span>def <span class="ident">get_action_uid_by_name</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_action_uid_by_name(self, name):
    return self.get_element_uid_by_name(ElementType.action, name)</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.get_actions_with_action_data_name"><code class="name flex">
<span>def <span class="ident">get_actions_with_action_data_name</span></span>(<span>self, data_name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_actions_with_action_data_name(self, data_name):
    return self.get_elements_with_element_data_name(ElementType.action, data_name)</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.get_all"><code class="name flex">
<span>def <span class="ident">get_all</span></span>(<span>self, element_type)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns all elements of the specified ElementType.
e.g. all Object's or Context's</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_all(self, element_type):
    &#34;&#34;&#34;
    Returns all elements of the specified ElementType.
    e.g. all Object&#39;s or Context&#39;s
    &#34;&#34;&#34;
    assert(isinstance(element_type, ElementType))
    return self.data[&#39;vcd&#39;].get(element_type.name + &#39;s&#39;)</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.get_context"><code class="name flex">
<span>def <span class="ident">get_context</span></span>(<span>self, uid)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_context(self, uid):
    return self.get_element(ElementType.context, uid)</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.get_context_data"><code class="name flex">
<span>def <span class="ident">get_context_data</span></span>(<span>self, uid, data_name, frame_num=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_context_data(self, uid, data_name, frame_num=None):
    return self.get_element_data(ElementType.context, uid, data_name, frame_num)</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.get_context_data_frame_intervals"><code class="name flex">
<span>def <span class="ident">get_context_data_frame_intervals</span></span>(<span>self, uid, data_name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_context_data_frame_intervals(self, uid, data_name):
    return self.get_element_data_frame_intervals(ElementType.context, uid, data_name)</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.get_context_uid_by_name"><code class="name flex">
<span>def <span class="ident">get_context_uid_by_name</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_context_uid_by_name(self, name):
    return self.get_element_uid_by_name(ElementType.context, name)</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.get_contexts_with_context_data_name"><code class="name flex">
<span>def <span class="ident">get_contexts_with_context_data_name</span></span>(<span>self, data_name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_contexts_with_context_data_name(self, data_name):
    return self.get_elements_with_element_data_name(ElementType.context, data_name)</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.get_coordinate_system"><code class="name flex">
<span>def <span class="ident">get_coordinate_system</span></span>(<span>self, coordinate_system)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_coordinate_system(self, coordinate_system):
    if self.has_coordinate_system(coordinate_system):
        return copy.deepcopy(self.data[&#39;vcd&#39;][&#39;coordinate_systems&#39;][coordinate_system])
    else:
        return None</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.get_coordinate_systems"><code class="name flex">
<span>def <span class="ident">get_coordinate_systems</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_coordinate_systems(self):
    if &#39;coordinate_systems&#39; in self.data[&#39;vcd&#39;]:
        return copy.deepcopy(self.data[&#39;vcd&#39;][&#39;coordinate_systems&#39;])
    else:
        return []</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.get_data"><code class="name flex">
<span>def <span class="ident">get_data</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_data(self):
    return self.data</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.get_element"><code class="name flex">
<span>def <span class="ident">get_element</span></span>(<span>self, element_type, uid)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element(self, element_type, uid):
    assert (isinstance(element_type, ElementType))
    if self.data[&#39;vcd&#39;].get(element_type.name + &#39;s&#39;) is None:
        warnings.warn(&#34;WARNING: trying to get a &#34; + element_type.name + &#34; but this VCD has none.&#34;)
        return None
    uid_str = UID(uid).as_str()
    if uid_str in self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;]:
        return self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;][uid_str]
    else:
        warnings.warn(&#34;WARNING: trying to get non-existing &#34; + element_type.name + &#34; with uid: &#34; + uid_str)
        return None</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.get_element_data"><code class="name flex">
<span>def <span class="ident">get_element_data</span></span>(<span>self, element_type, uid, data_name, frame_num=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element_data(self, element_type, uid, data_name, frame_num=None):
    element_exists = self.has(element_type, uid)
    vcd_has_frames = not self.get_frame_intervals().empty()

    if not element_exists:  # the element does not exist
        return None

    if not vcd_has_frames and frame_num is not None:  # don&#39;t ask for frame-specific info in a VCD without frames
        return None

    frame_num_is_number = isinstance(frame_num, int)
    uid_str = UID(uid).as_str()

    element_exists_in_this_frame = False
    if frame_num is not None and frame_num_is_number:
        # The user is asking for frame-specific attributes

        found_in_frame = False
        frame = self.get_frame(frame_num)
        if frame is not None:
            if element_type.name + &#39;s&#39; in frame:
                if uid_str in frame[element_type.name + &#39;s&#39;]:
                    element_exists_in_this_frame = True
                    element = frame[element_type.name + &#39;s&#39;][uid_str]
                    if element_type.name + &#39;_data&#39; in element:
                        for prop in element[element_type.name + &#39;_data&#39;]:
                            val_array = element[element_type.name + &#39;_data&#39;][prop]
                            for val in val_array:
                                if val[&#39;name&#39;] == data_name:
                                    return val
        if not found_in_frame:
            # The user has asked to get an element_data for a certain frame, but there is no info about this
            # element or element_data at this frame
            if not element_exists_in_this_frame:
                return None
            element = self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;][uid_str]  # the element exists because of prev. ctrl
            for prop in element[element_type.name + &#39;_data&#39;]:
                val_array = element[element_type.name + &#39;_data&#39;][prop]
                for val in val_array:
                    if val[&#39;name&#39;] == data_name:
                        return val
    else:
        # The user is asking for static attributes at the root of the element
        element = self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;][uid_str]  # the element exists because of prev. ctrl
        for prop in element[element_type.name + &#39;_data&#39;]:
            val_array = element[element_type.name + &#39;_data&#39;][prop]
            for val in val_array:
                if val[&#39;name&#39;] == data_name:
                    return val
    return None</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.get_element_data_count_per_type"><code class="name flex">
<span>def <span class="ident">get_element_data_count_per_type</span></span>(<span>self, element_type, uid, data_type, frame_num=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element_data_count_per_type(self, element_type, uid, data_type, frame_num=None):
    # Returns 0 if no such element exist or if the element does not have the data_type
    # Returns the count otherwise (e.g. how many &#34;bbox&#34; does this object have)
    assert(isinstance(data_type, types.ObjectDataType))
    uid_str = UID(uid).as_str()
    if self.has(element_type, uid):
        if frame_num is not None:
            # Dynamic info
            if not isinstance(frame_num, int):
                warnings.warn(&#34;WARNING: Calling get_element_data with a non-integer frame_num.&#34;)
            frame = self.get_frame(frame_num)
            if frame is not None:
                if element_type.name + &#39;s&#39; in frame:
                    if uid_str in frame[element_type.name + &#39;s&#39;]:
                        element = frame[element_type.name + &#39;s&#39;][uid_str]
                        for prop in element[element_type.name + &#39;_data&#39;]:
                            if prop == data_type.name:
                                return len(element[element_type.name + &#39;_data&#39;][prop])
                    else:
                        return 0
                else:
                    return 0
        else:
            # Static info
            element = self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;][uid_str]
            for prop in element[element_type.name + &#39;_data&#39;]:
                if prop == data_type.name:
                    return len(element[element_type.name + &#39;_data&#39;][prop])
    else:
        return 0
    return 0</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.get_element_data_frame_intervals"><code class="name flex">
<span>def <span class="ident">get_element_data_frame_intervals</span></span>(<span>self, element_type, uid, data_name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element_data_frame_intervals(self, element_type, uid, data_name):
    return FrameIntervals(self.get_element_data_pointer(element_type, uid, data_name)[&#39;frame_intervals&#39;])</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.get_element_data_pointer"><code class="name flex">
<span>def <span class="ident">get_element_data_pointer</span></span>(<span>self, element_type, uid, data_name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element_data_pointer(self, element_type, uid, data_name):
    uid_str = UID(uid).as_str()
    if self.has(element_type, uid):
        if element_type.name + &#39;s&#39; in self.data[&#39;vcd&#39;]:
            if uid_str in self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;]:
                element = self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;][uid_str]
                if element_type.name + &#39;_data_pointers&#39; in element:
                    if data_name in element[element_type.name + &#39;_data_pointers&#39;]:
                        return element[element_type.name + &#39;_data_pointers&#39;][data_name]
    else:
        warnings.warn(&#34;WARNING: Asking element data from a non-existing Element.&#34;)
    return None</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.get_element_frame_intervals"><code class="name flex">
<span>def <span class="ident">get_element_frame_intervals</span></span>(<span>self, element_type, uid)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element_frame_intervals(self, element_type, uid):
    uid_str = UID(uid).as_str()
    if not element_type.name + &#39;s&#39; in self.data[&#39;vcd&#39;]:
        return FrameIntervals()
    else:
        if not uid_str in self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;]:
            return FrameIntervals()
        return FrameIntervals(self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;][uid_str].get(&#39;frame_intervals&#39;))</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.get_element_uid_by_name"><code class="name flex">
<span>def <span class="ident">get_element_uid_by_name</span></span>(<span>self, element_type, name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element_uid_by_name(self, element_type, name):
    assert (self.has_elements(element_type))
    element_type_name = element_type.name
    elements = self.data[&#39;vcd&#39;][element_type_name + &#39;s&#39;]
    for uid, element in elements.items():
        name_element = element[&#39;name&#39;]
        if name_element == name:
            return uid
    return None</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.get_elements_of_type"><code class="name flex">
<span>def <span class="ident">get_elements_of_type</span></span>(<span>self, element_type, semantic_type)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_elements_of_type(self, element_type, semantic_type):
    uids_str = []
    if not element_type.name + &#39;s&#39; in self.data[&#39;vcd&#39;]:
        return uids_str
    for uid_str, element in self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;].items():
        if element[&#39;type&#39;] == semantic_type:
            uids_str.append(uid_str)
    return uids_str</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.get_elements_uids"><code class="name flex">
<span>def <span class="ident">get_elements_uids</span></span>(<span>self, element_type:Â <a title="vcd.core.ElementType" href="#vcd.core.ElementType">ElementType</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_elements_uids(self, element_type: ElementType):
    if self.has_elements(element_type):
        list_of_uids = list(self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;].keys())
        return list_of_uids
    else:
        return []</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.get_elements_with_element_data_name"><code class="name flex">
<span>def <span class="ident">get_elements_with_element_data_name</span></span>(<span>self, element_type, data_name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_elements_with_element_data_name(self, element_type, data_name):
    uids_str = []
    for uid_str in self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;]:
        element = self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;][uid_str]
        if element_type.name + &#39;_data_pointers&#39; in element:
            for name in element[element_type.name + &#39;_data_pointers&#39;]:
                if name == data_name:
                    uids_str.append(uid_str)
                    break
    return uids_str</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.get_event"><code class="name flex">
<span>def <span class="ident">get_event</span></span>(<span>self, uid)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_event(self, uid):
    return self.get_element(ElementType.event, uid)</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.get_event_data"><code class="name flex">
<span>def <span class="ident">get_event_data</span></span>(<span>self, uid, data_name, frame_num=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_event_data(self, uid, data_name, frame_num=None):
    return self.get_element_data(ElementType.event, uid, data_name, frame_num)</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.get_event_data_frame_intervals"><code class="name flex">
<span>def <span class="ident">get_event_data_frame_intervals</span></span>(<span>self, uid, data_name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_event_data_frame_intervals(self, uid, data_name):
    return self.get_element_data_frame_intervals(ElementType.event, uid, data_name)</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.get_event_uid_by_name"><code class="name flex">
<span>def <span class="ident">get_event_uid_by_name</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_event_uid_by_name(self, name):
    return self.get_element_uid_by_name(ElementType.event, name)</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.get_events_with_event_data_name"><code class="name flex">
<span>def <span class="ident">get_events_with_event_data_name</span></span>(<span>self, data_name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_events_with_event_data_name(self, data_name):
    return self.get_elements_with_element_data_name(ElementType.event, data_name)</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.get_frame"><code class="name flex">
<span>def <span class="ident">get_frame</span></span>(<span>self, frame_num)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_frame(self, frame_num):
    if &#39;frames&#39; not in self.data[&#39;vcd&#39;]:
        return None
    else:
        frame = self.data[&#39;vcd&#39;][&#39;frames&#39;].get(frame_num)
        return frame</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.get_frame_intervals"><code class="name flex">
<span>def <span class="ident">get_frame_intervals</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_frame_intervals(self):
    if &#39;frame_intervals&#39; in self.data[&#39;vcd&#39;]:
        return FrameIntervals(self.data[&#39;vcd&#39;][&#39;frame_intervals&#39;])
    else:
        return FrameIntervals()</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.get_frames_with_action_data_name"><code class="name flex">
<span>def <span class="ident">get_frames_with_action_data_name</span></span>(<span>self, uid, data_name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_frames_with_action_data_name(self, uid, data_name):
    return self.get_frames_with_element_data_name(ElementType.action, uid, data_name)</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.get_frames_with_context_data_name"><code class="name flex">
<span>def <span class="ident">get_frames_with_context_data_name</span></span>(<span>self, uid, data_name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_frames_with_context_data_name(self, uid, data_name):
    return self.get_frames_with_element_data_name(ElementType.context, uid, data_name)</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.get_frames_with_element_data_name"><code class="name flex">
<span>def <span class="ident">get_frames_with_element_data_name</span></span>(<span>self, element_type, uid, data_name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_frames_with_element_data_name(self, element_type, uid, data_name):
    uid_str = UID(uid).as_str()
    if uid_str in self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;]:
        element = self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;][uid_str]
        if element_type.name + &#39;_data_pointers&#39; in element:
            for name in element[element_type.name + &#39;_data_pointers&#39;]:
                if name == data_name:
                    return FrameIntervals(element[element_type.name + &#39;_data_pointers&#39;][name][&#39;frame_intervals&#39;])
    return None</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.get_frames_with_event_data_name"><code class="name flex">
<span>def <span class="ident">get_frames_with_event_data_name</span></span>(<span>self, uid, data_name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_frames_with_event_data_name(self, uid, data_name):
    return self.get_frames_with_element_data_name(ElementType.event, uid, data_name)</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.get_frames_with_object_data_name"><code class="name flex">
<span>def <span class="ident">get_frames_with_object_data_name</span></span>(<span>self, uid, data_name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_frames_with_object_data_name(self, uid, data_name):
    return self.get_frames_with_element_data_name(ElementType.object, uid, data_name)</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.get_metadata"><code class="name flex">
<span>def <span class="ident">get_metadata</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_metadata(self):
    if &#39;metadata&#39; in self.data[&#39;vcd&#39;]:
        return self.data[&#39;vcd&#39;][&#39;metadata&#39;]
    else:
        return dict()</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.get_num_actions"><code class="name flex">
<span>def <span class="ident">get_num_actions</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_num_actions(self):
    return self.get_num_elements(ElementType.action)</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.get_num_contexts"><code class="name flex">
<span>def <span class="ident">get_num_contexts</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_num_contexts(self):
    return self.get_num_elements(ElementType.context)</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.get_num_elements"><code class="name flex">
<span>def <span class="ident">get_num_elements</span></span>(<span>self, element_type)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_num_elements(self, element_type):
    if self.has_elements(element_type):
        return len(self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;])
    else:
        return 0</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.get_num_events"><code class="name flex">
<span>def <span class="ident">get_num_events</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_num_events(self):
    return self.get_num_elements(ElementType.event)</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.get_num_objects"><code class="name flex">
<span>def <span class="ident">get_num_objects</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_num_objects(self):
    return self.get_num_elements(ElementType.object)</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.get_num_relations"><code class="name flex">
<span>def <span class="ident">get_num_relations</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_num_relations(self):
    return self.get_num_elements(ElementType.relation)</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.get_object"><code class="name flex">
<span>def <span class="ident">get_object</span></span>(<span>self, uid)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_object(self, uid):
    return self.get_element(ElementType.object, uid)</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.get_object_data"><code class="name flex">
<span>def <span class="ident">get_object_data</span></span>(<span>self, uid, data_name, frame_num=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_object_data(self, uid, data_name, frame_num=None):
    return self.get_element_data(ElementType.object, uid, data_name, frame_num)</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.get_object_data_frame_intervals"><code class="name flex">
<span>def <span class="ident">get_object_data_frame_intervals</span></span>(<span>self, uid, data_name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_object_data_frame_intervals(self, uid, data_name):
    return self.get_element_data_frame_intervals(ElementType.object, uid, data_name)</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.get_object_uid_by_name"><code class="name flex">
<span>def <span class="ident">get_object_uid_by_name</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_object_uid_by_name(self, name):
    return self.get_element_uid_by_name(ElementType.object, name)</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.get_objects_with_object_data_name"><code class="name flex">
<span>def <span class="ident">get_objects_with_object_data_name</span></span>(<span>self, data_name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_objects_with_object_data_name(self, data_name):
    return self.get_elements_with_element_data_name(ElementType.object, data_name)</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.get_ontology"><code class="name flex">
<span>def <span class="ident">get_ontology</span></span>(<span>self, ont_uid)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_ontology(self, ont_uid):
    ont_uid_str = UID(ont_uid).as_str()
    if &#39;ontologies&#39; in self.data[&#39;vcd&#39;]:
        if ont_uid_str in self.data[&#39;vcd&#39;][&#39;ontologies&#39;]:
            return copy.deepcopy(self.data[&#39;vcd&#39;][&#39;ontologies&#39;][ont_uid_str])
    return None</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.get_relation"><code class="name flex">
<span>def <span class="ident">get_relation</span></span>(<span>self, uid)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_relation(self, uid):
    return self.get_element(ElementType.relation, uid)</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.get_relation_uid_by_name"><code class="name flex">
<span>def <span class="ident">get_relation_uid_by_name</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_relation_uid_by_name(self, name):
    return self.get_element_uid_by_name(ElementType.relation, name)</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.get_stream"><code class="name flex">
<span>def <span class="ident">get_stream</span></span>(<span>self, stream_name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_stream(self, stream_name):
    if self.has_stream(stream_name):
        return copy.deepcopy(self.data[&#39;vcd&#39;][&#39;streams&#39;][stream_name])
    else:
        return None</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.get_streams"><code class="name flex">
<span>def <span class="ident">get_streams</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_streams(self):
    if &#39;streams&#39; in self.data[&#39;vcd&#39;]:
        return copy.deepcopy(self.data[&#39;vcd&#39;][&#39;streams&#39;])
    else:
        return {}</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.has"><code class="name flex">
<span>def <span class="ident">has</span></span>(<span>self, element_type, uid)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has(self, element_type, uid):
    if not element_type.name + &#39;s&#39; in self.data[&#39;vcd&#39;]:
        return False
    else:
        uid_str = UID(uid).as_str()
        if uid_str in self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;]:
            return True
        else:
            return False</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.has_actions"><code class="name flex">
<span>def <span class="ident">has_actions</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_actions(self):
    return &#39;actions&#39; in self.data[&#39;vcd&#39;]</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.has_contexts"><code class="name flex">
<span>def <span class="ident">has_contexts</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_contexts(self):
    return &#39;contexts&#39; in self.data[&#39;vcd&#39;]</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.has_coordinate_system"><code class="name flex">
<span>def <span class="ident">has_coordinate_system</span></span>(<span>self, cs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_coordinate_system(self, cs):
    if &#39;coordinate_systems&#39; in self.data[&#39;vcd&#39;]:
        if cs in self.data[&#39;vcd&#39;][&#39;coordinate_systems&#39;]:
            return True
    return False</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.has_element_data"><code class="name flex">
<span>def <span class="ident">has_element_data</span></span>(<span>self, element_type, uid, element_data)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_element_data(self, element_type, uid, element_data):
    if not self.has(element_type, uid):
        return False
    else:
        uid_str = UID(uid).as_str()
        if element_type.name + &#39;_data_pointers&#39; not in self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;][uid_str]:
            return False
        name = element_data.data[&#39;name&#39;]
        return name in self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;][uid_str][element_type.name + &#39;_data_pointers&#39;]</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.has_elements"><code class="name flex">
<span>def <span class="ident">has_elements</span></span>(<span>self, element_type)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_elements(self, element_type):
    element_type_name = element_type.name
    return element_type_name + &#39;s&#39; in self.data[&#39;vcd&#39;]</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.has_events"><code class="name flex">
<span>def <span class="ident">has_events</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_events(self):
    return &#39;events&#39; in self.data[&#39;vcd&#39;]</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.has_frame"><code class="name flex">
<span>def <span class="ident">has_frame</span></span>(<span>self, frame_num)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_frame(self, frame_num):
    if &#39;frames&#39; not in self.data[&#39;vcd&#39;]:
        return False
    else:
        if frame_num in self.data[&#39;vcd&#39;][&#39;frames&#39;]:
            return True
        else:
            return False</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.has_objects"><code class="name flex">
<span>def <span class="ident">has_objects</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_objects(self):
    return &#39;objects&#39; in self.data[&#39;vcd&#39;]</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.has_relations"><code class="name flex">
<span>def <span class="ident">has_relations</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_relations(self):
    return &#39;relations&#39; in self.data[&#39;vcd&#39;]</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.has_stream"><code class="name flex">
<span>def <span class="ident">has_stream</span></span>(<span>self, stream_name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_stream(self, stream_name):
    if &#39;streams&#39; in self.data[&#39;vcd&#39;]:
        if stream_name in self.data[&#39;vcd&#39;][&#39;streams&#39;]:
            return True
        else:
            return False</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.relation_has_frame_intervals"><code class="name flex">
<span>def <span class="ident">relation_has_frame_intervals</span></span>(<span>self, relation_uid)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def relation_has_frame_intervals(self, relation_uid):
    rel_uid = UID(relation_uid)
    relation = self.get_relation(relation_uid)
    if relation is None:
        warnings.warn(&#34;WARNING: Non-existing relation &#34; + rel_uid.as_str())
    else:
        if &#39;frame_intervals&#39; not in relation:
            return False
        else:
            if len(relation[&#39;frame_intervals&#39;]) == 0:
                return False
            else:
                return True</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset(self):
    # Main VCD data
    self.data = {&#39;vcd&#39;: {}}
    self.data[&#39;vcd&#39;][&#39;metadata&#39;] = {}
    self.data[&#39;vcd&#39;][&#39;metadata&#39;][&#39;schema_version&#39;] = schema.vcd_schema_version

    # Schema information
    self.schema = schema.vcd_schema

    # Additional auxiliary structures
    self.__lastUID = dict()
    self.__lastUID[ElementType.object] = -1
    self.__lastUID[ElementType.action] = -1
    self.__lastUID[ElementType.event] = -1
    self.__lastUID[ElementType.context] = -1
    self.__lastUID[ElementType.relation] = -1</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.rm_action"><code class="name flex">
<span>def <span class="ident">rm_action</span></span>(<span>self, uid)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rm_action(self, uid):
    self.rm_element(ElementType.action, uid)</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.rm_action_by_type"><code class="name flex">
<span>def <span class="ident">rm_action_by_type</span></span>(<span>self, semantic_type)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rm_action_by_type(self, semantic_type):
    self.rm_element_by_type(ElementType.action, semantic_type)</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.rm_context"><code class="name flex">
<span>def <span class="ident">rm_context</span></span>(<span>self, uid)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rm_context(self, uid):
    self.rm_element(ElementType.context, uid)</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.rm_context_by_type"><code class="name flex">
<span>def <span class="ident">rm_context_by_type</span></span>(<span>self, semantic_type)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rm_context_by_type(self, semantic_type):
    self.rm_element_by_type(ElementType.context, semantic_type)</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.rm_element"><code class="name flex">
<span>def <span class="ident">rm_element</span></span>(<span>self, element_type, uid)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rm_element(self, element_type, uid):
    uid_str = UID(uid).as_str()
    if not self.has_elements(element_type):
        return

    # Get element from summary
    if not self.has(element_type, uid):
        return

    # Remove from frames: let&#39;s read frame_intervals from summary
    elements = self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;]
    element = elements[uid_str]
    if &#39;frame_intervals&#39; in element:
        for i in range(0, len(element[&#39;frame_intervals&#39;])):
            fi = element[&#39;frame_intervals&#39;][i]
            for frame_num in range(fi[&#39;frame_start&#39;], fi[&#39;frame_end&#39;]+1):
                elements_in_frame = self.data[&#39;vcd&#39;][&#39;frames&#39;][frame_num][element_type.name + &#39;s&#39;]
                if uid in elements_in_frame:
                    del elements_in_frame[uid_str]
                if len(elements_in_frame) == 0:  # objects might have end up empty TODO: test this
                    del self.data[&#39;vcd&#39;][&#39;frames&#39;][frame_num][element_type.name + &#39;s&#39;]
                    if len(self.data[&#39;vcd&#39;][&#39;frames&#39;][frame_num]) == 0:  # this frame may have ended up being empty
                        del self.data[&#39;vcd&#39;][&#39;frames&#39;][frame_num]
                        self.__rm_frame(frame_num)

    # Delete this element from summary
    del elements[uid_str]
    if len(elements) == 0:
        del self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;]</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.rm_element_by_type"><code class="name flex">
<span>def <span class="ident">rm_element_by_type</span></span>(<span>self, element_type, semantic_type)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rm_element_by_type(self, element_type, semantic_type):
    elements = self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;]

    # Get Element from summary
    uids_to_remove_str = []
    for uid_str, element in elements.items():
        if element[&#39;type&#39;] == semantic_type:
            uids_to_remove_str.append(uid_str)
    for uid_str in uids_to_remove_str:
        self.rm_element(element_type, uid_str)</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.rm_element_data_from_frames"><code class="name flex">
<span>def <span class="ident">rm_element_data_from_frames</span></span>(<span>self, element_type, uid, frame_intervals)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rm_element_data_from_frames(self, element_type, uid, frame_intervals):
    for fi in frame_intervals.get():
        for f in range(fi[0], fi[1] + 1):
            if self.has_frame(f):
                frame = self.data[&#39;vcd&#39;][&#39;frames&#39;][f]
                if element_type.name + &#39;s&#39; in frame:
                    if uid.as_str() in frame[element_type.name + &#39;s&#39;]:
                        element = frame[element_type.name + &#39;s&#39;][uid.as_str()]
                        if element_type.name + &#39;_data&#39; in element:
                            # Delete all its former dyamic element_data entries at old fis
                            del element[element_type.name + &#39;_data&#39;]

    # Clean-up data pointers of object_data that no longer exist!
    # Note, element_data_pointers are correctly updated, but there might be some now declared as static
    # corresponding to element_data that was dynamic but now has been removed when the element changed to static
    if self.has(element_type, uid.as_str()):
        element = self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;][uid.as_str()]
        if element_type.name + &#39;_data_pointers&#39; in element:
            edps = element[element_type.name + &#39;_data_pointers&#39;]
            edp_names_to_delete = []
            for edp_name in edps:
                fis_ed = FrameIntervals(edps[edp_name][&#39;frame_intervals&#39;])
                if fis_ed.empty():
                    # Check if element_data exists
                    ed_type = edps[edp_name][&#39;type&#39;]
                    found = False
                    if element_type.name + &#39;_data&#39; in element:
                        if ed_type in element[element_type.name + &#39;_data&#39;]:
                            for ed in element[element_type.name + &#39;_data&#39;][ed_type]:
                                if ed[&#39;name&#39;] == edp_name:
                                    found = True
                                    break
                    if not found:
                        edp_names_to_delete.append(edp_name)
            for edp_name in edp_names_to_delete:
                del element[element_type.name + &#39;_data_pointers&#39;][edp_name]</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.rm_element_data_from_frames_by_name"><code class="name flex">
<span>def <span class="ident">rm_element_data_from_frames_by_name</span></span>(<span>self, element_type, uid, element_data_name, frame_intervals)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rm_element_data_from_frames_by_name(self, element_type, uid, element_data_name, frame_intervals):
    for fi in frame_intervals.get():
        for f in range(fi[0], fi[1] + 1):
            if self.has_frame(f):
                frame = self.data[&#39;vcd&#39;][&#39;frames&#39;][f]
                if element_type.name + &#39;s&#39; in frame:
                    if uid.as_str() in frame[element_type.name + &#39;s&#39;]:
                        element = frame[element_type.name + &#39;s&#39;][uid.as_str()]
                        if element_type.name + &#39;_data&#39; in element:
                            # Delete only the element_data with the specified name
                            for prop in element[element_type.name + &#39;_data&#39;]:
                                val_array = element[element_type.name + &#39;_data&#39;][prop]
                                for i in range(0, len(val_array)):
                                    val = val_array[i]
                                    if val[&#39;name&#39;] == element_data_name:
                                        del element[element_type.name + &#39;_data&#39;][prop][i]</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.rm_event"><code class="name flex">
<span>def <span class="ident">rm_event</span></span>(<span>self, uid)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rm_event(self, uid):
    self.rm_element(ElementType.event, uid)</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.rm_event_by_type"><code class="name flex">
<span>def <span class="ident">rm_event_by_type</span></span>(<span>self, semantic_type)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rm_event_by_type(self, semantic_type):
    self.rm_element_by_type(ElementType.event, semantic_type)</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.rm_object"><code class="name flex">
<span>def <span class="ident">rm_object</span></span>(<span>self, uid)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rm_object(self, uid):
    self.rm_element(ElementType.object, uid)</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.rm_object_by_type"><code class="name flex">
<span>def <span class="ident">rm_object_by_type</span></span>(<span>self, semantic_type)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rm_object_by_type(self, semantic_type):
    self.rm_element_by_type(ElementType.object, semantic_type)</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.rm_relation"><code class="name flex">
<span>def <span class="ident">rm_relation</span></span>(<span>self, uid)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rm_relation(self, uid):
    self.rm_element(ElementType.relation, uid)</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.rm_relation_by_type"><code class="name flex">
<span>def <span class="ident">rm_relation_by_type</span></span>(<span>self, semantic_type)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rm_relation_by_type(self, semantic_type):
    self.rm_element_by_type(ElementType.relation, semantic_type)</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, file_name, pretty=False, validate=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(self, file_name, pretty=False, validate=False):
    string = self.stringify(pretty, validate)
    file = open(file_name, &#39;w&#39;)
    file.write(string)
    file.close()</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.save_frame"><code class="name flex">
<span>def <span class="ident">save_frame</span></span>(<span>self, frame_num, file_name, dynamic_only=True, pretty=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_frame(self, frame_num, file_name, dynamic_only=True, pretty=False):
    string = self.stringify_frame(frame_num, dynamic_only, pretty)
    file = open(file_name, &#39;w&#39;)
    file.write(string)
    file.close()</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.set_use_uuid"><code class="name flex">
<span>def <span class="ident">set_use_uuid</span></span>(<span>self, val)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_use_uuid(self, val):
    assert(isinstance(val, bool))
    self.use_uuid = val</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.stringify"><code class="name flex">
<span>def <span class="ident">stringify</span></span>(<span>self, pretty=True, validate=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stringify(self, pretty=True, validate=True):
    if pretty:
        stringified_vcd = json.dumps(self.data, indent=4, sort_keys=False)

    else:
        stringified_vcd = json.dumps(self.data, separators=(&#39;,&#39;, &#39;:&#39;), sort_keys=False)
    if validate:
        self.validate(stringified_vcd)
    return stringified_vcd</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.stringify_frame"><code class="name flex">
<span>def <span class="ident">stringify_frame</span></span>(<span>self, frame_num, dynamic_only=True, pretty=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stringify_frame(self, frame_num, dynamic_only=True, pretty=False):
    if frame_num not in self.data[&#39;vcd&#39;][&#39;frames&#39;]:
        warnings.warn(&#34;WARNING: Trying to stringify a non-existing frame.&#34;)
        return &#39;&#39;

    if dynamic_only:
        if pretty:
            return json.dumps(self.data[&#39;vcd&#39;][&#39;frames&#39;][frame_num], indent=4, sort_keys=True)
        else:
            return json.dumps(self.data[&#39;vcd&#39;][&#39;frames&#39;][frame_num])

    else:
        # Need to compose dynamic and static information into a new structure
        # Copy the dynamic info first
        frame_static_dynamic = copy.deepcopy(self.data[&#39;vcd&#39;][&#39;frames&#39;][frame_num])  # Needs to be a copy!

        # Now the static info for objects, actions, events, contexts and relations
        # Relations can be frame-less or frame-specific
        for element_type in ElementType:
            # First, elements explicitly defined for this frame
            if element_type.name + &#39;s&#39; in self.data[&#39;vcd&#39;][&#39;frames&#39;][frame_num]:
                for uid, content in self.data[&#39;vcd&#39;][&#39;frames&#39;][frame_num][element_type.name + &#39;s&#39;].items():
                    frame_static_dynamic[element_type.name + &#39;s&#39;][uid].update(
                        self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;][uid]
                    )
                    # Remove frameInterval entry
                    if &#39;frame_intervals&#39; in frame_static_dynamic[element_type.name + &#39;s&#39;][uid]:
                        del frame_static_dynamic[element_type.name + &#39;s&#39;][uid][&#39;frame_intervals&#39;]

            # But also other elements without frame intervals specified, which are assumed to exist during
            # the entire sequence, except frame-less Relations which are assumed to not be associated to any frame
            if element_type.name + &#39;s&#39; in self.data[&#39;vcd&#39;] and element_type.name != &#39;relation&#39;:
                for uid, element in self.data[&#39;vcd&#39;][element_type.name + &#39;s&#39;].items():
                    frame_intervals_dict = element.get(&#39;frame_intervals&#39;)
                    if frame_intervals_dict is None or not frame_intervals_dict:
                        # So the list of frame intervals is empty -&gt; this element lives the entire scene
                        # Let&#39;s add it to frame_static_dynamic
                        frame_static_dynamic.setdefault(element_type.name + &#39;s&#39;, dict()) # in case there are no
                                                                    # such type of elements already in this frame
                        frame_static_dynamic[element_type.name + &#39;s&#39;][uid] = dict()
                        frame_static_dynamic[element_type.name + &#39;s&#39;][uid] = copy.deepcopy(element)

                        # Remove frameInterval entry
                        if &#39;frame_intervals&#39; in frame_static_dynamic[element_type.name + &#39;s&#39;][uid]:
                            del frame_static_dynamic[element_type.name + &#39;s&#39;][uid][&#39;frame_intervals&#39;]

        if pretty:
            return json.dumps(frame_static_dynamic, indent=4, sort_keys=True)
        else:
            return json.dumps(frame_static_dynamic)</code></pre>
</details>
</dd>
<dt id="vcd.core.VCD.validate"><code class="name flex">
<span>def <span class="ident">validate</span></span>(<span>self, stringified_vcd)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate(self, stringified_vcd):
    temp = json.loads(stringified_vcd)
    if not hasattr(self, &#39;schema&#39;):
        self.schema = schema.vcd_schema
    validate(instance=temp, schema=self.schema)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="vcd" href="index.html">vcd</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="vcd.core.ElementType" href="#vcd.core.ElementType">ElementType</a></code></h4>
<ul class="">
<li><code><a title="vcd.core.ElementType.action" href="#vcd.core.ElementType.action">action</a></code></li>
<li><code><a title="vcd.core.ElementType.context" href="#vcd.core.ElementType.context">context</a></code></li>
<li><code><a title="vcd.core.ElementType.event" href="#vcd.core.ElementType.event">event</a></code></li>
<li><code><a title="vcd.core.ElementType.object" href="#vcd.core.ElementType.object">object</a></code></li>
<li><code><a title="vcd.core.ElementType.relation" href="#vcd.core.ElementType.relation">relation</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vcd.core.FrameIntervals" href="#vcd.core.FrameIntervals">FrameIntervals</a></code></h4>
<ul class="two-column">
<li><code><a title="vcd.core.FrameIntervals.contains" href="#vcd.core.FrameIntervals.contains">contains</a></code></li>
<li><code><a title="vcd.core.FrameIntervals.empty" href="#vcd.core.FrameIntervals.empty">empty</a></code></li>
<li><code><a title="vcd.core.FrameIntervals.equals" href="#vcd.core.FrameIntervals.equals">equals</a></code></li>
<li><code><a title="vcd.core.FrameIntervals.get" href="#vcd.core.FrameIntervals.get">get</a></code></li>
<li><code><a title="vcd.core.FrameIntervals.get_dict" href="#vcd.core.FrameIntervals.get_dict">get_dict</a></code></li>
<li><code><a title="vcd.core.FrameIntervals.get_length" href="#vcd.core.FrameIntervals.get_length">get_length</a></code></li>
<li><code><a title="vcd.core.FrameIntervals.get_outer" href="#vcd.core.FrameIntervals.get_outer">get_outer</a></code></li>
<li><code><a title="vcd.core.FrameIntervals.has_frame" href="#vcd.core.FrameIntervals.has_frame">has_frame</a></code></li>
<li><code><a title="vcd.core.FrameIntervals.intersection" href="#vcd.core.FrameIntervals.intersection">intersection</a></code></li>
<li><code><a title="vcd.core.FrameIntervals.is_contained_by" href="#vcd.core.FrameIntervals.is_contained_by">is_contained_by</a></code></li>
<li><code><a title="vcd.core.FrameIntervals.rm_frame" href="#vcd.core.FrameIntervals.rm_frame">rm_frame</a></code></li>
<li><code><a title="vcd.core.FrameIntervals.to_str" href="#vcd.core.FrameIntervals.to_str">to_str</a></code></li>
<li><code><a title="vcd.core.FrameIntervals.union" href="#vcd.core.FrameIntervals.union">union</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vcd.core.RDF" href="#vcd.core.RDF">RDF</a></code></h4>
<ul class="">
<li><code><a title="vcd.core.RDF.object" href="#vcd.core.RDF.object">object</a></code></li>
<li><code><a title="vcd.core.RDF.subject" href="#vcd.core.RDF.subject">subject</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vcd.core.SetMode" href="#vcd.core.SetMode">SetMode</a></code></h4>
<ul class="">
<li><code><a title="vcd.core.SetMode.replace" href="#vcd.core.SetMode.replace">replace</a></code></li>
<li><code><a title="vcd.core.SetMode.union" href="#vcd.core.SetMode.union">union</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vcd.core.StreamType" href="#vcd.core.StreamType">StreamType</a></code></h4>
<ul class="">
<li><code><a title="vcd.core.StreamType.camera" href="#vcd.core.StreamType.camera">camera</a></code></li>
<li><code><a title="vcd.core.StreamType.gps_imu" href="#vcd.core.StreamType.gps_imu">gps_imu</a></code></li>
<li><code><a title="vcd.core.StreamType.lidar" href="#vcd.core.StreamType.lidar">lidar</a></code></li>
<li><code><a title="vcd.core.StreamType.other" href="#vcd.core.StreamType.other">other</a></code></li>
<li><code><a title="vcd.core.StreamType.radar" href="#vcd.core.StreamType.radar">radar</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vcd.core.UID" href="#vcd.core.UID">UID</a></code></h4>
<ul class="">
<li><code><a title="vcd.core.UID.as_int" href="#vcd.core.UID.as_int">as_int</a></code></li>
<li><code><a title="vcd.core.UID.as_str" href="#vcd.core.UID.as_str">as_str</a></code></li>
<li><code><a title="vcd.core.UID.is_none" href="#vcd.core.UID.is_none">is_none</a></code></li>
<li><code><a title="vcd.core.UID.is_uuid" href="#vcd.core.UID.is_uuid">is_uuid</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vcd.core.VCD" href="#vcd.core.VCD">VCD</a></code></h4>
<ul class="">
<li><code><a title="vcd.core.VCD.add_action" href="#vcd.core.VCD.add_action">add_action</a></code></li>
<li><code><a title="vcd.core.VCD.add_action_data" href="#vcd.core.VCD.add_action_data">add_action_data</a></code></li>
<li><code><a title="vcd.core.VCD.add_annotator" href="#vcd.core.VCD.add_annotator">add_annotator</a></code></li>
<li><code><a title="vcd.core.VCD.add_comment" href="#vcd.core.VCD.add_comment">add_comment</a></code></li>
<li><code><a title="vcd.core.VCD.add_context" href="#vcd.core.VCD.add_context">add_context</a></code></li>
<li><code><a title="vcd.core.VCD.add_context_data" href="#vcd.core.VCD.add_context_data">add_context_data</a></code></li>
<li><code><a title="vcd.core.VCD.add_coordinate_system" href="#vcd.core.VCD.add_coordinate_system">add_coordinate_system</a></code></li>
<li><code><a title="vcd.core.VCD.add_element" href="#vcd.core.VCD.add_element">add_element</a></code></li>
<li><code><a title="vcd.core.VCD.add_element_data" href="#vcd.core.VCD.add_element_data">add_element_data</a></code></li>
<li><code><a title="vcd.core.VCD.add_event" href="#vcd.core.VCD.add_event">add_event</a></code></li>
<li><code><a title="vcd.core.VCD.add_event_data" href="#vcd.core.VCD.add_event_data">add_event_data</a></code></li>
<li><code><a title="vcd.core.VCD.add_file_version" href="#vcd.core.VCD.add_file_version">add_file_version</a></code></li>
<li><code><a title="vcd.core.VCD.add_frame_properties" href="#vcd.core.VCD.add_frame_properties">add_frame_properties</a></code></li>
<li><code><a title="vcd.core.VCD.add_metadata_properties" href="#vcd.core.VCD.add_metadata_properties">add_metadata_properties</a></code></li>
<li><code><a title="vcd.core.VCD.add_name" href="#vcd.core.VCD.add_name">add_name</a></code></li>
<li><code><a title="vcd.core.VCD.add_object" href="#vcd.core.VCD.add_object">add_object</a></code></li>
<li><code><a title="vcd.core.VCD.add_object_data" href="#vcd.core.VCD.add_object_data">add_object_data</a></code></li>
<li><code><a title="vcd.core.VCD.add_ontology" href="#vcd.core.VCD.add_ontology">add_ontology</a></code></li>
<li><code><a title="vcd.core.VCD.add_rdf" href="#vcd.core.VCD.add_rdf">add_rdf</a></code></li>
<li><code><a title="vcd.core.VCD.add_relation" href="#vcd.core.VCD.add_relation">add_relation</a></code></li>
<li><code><a title="vcd.core.VCD.add_relation_action_action" href="#vcd.core.VCD.add_relation_action_action">add_relation_action_action</a></code></li>
<li><code><a title="vcd.core.VCD.add_relation_action_object" href="#vcd.core.VCD.add_relation_action_object">add_relation_action_object</a></code></li>
<li><code><a title="vcd.core.VCD.add_relation_object_action" href="#vcd.core.VCD.add_relation_object_action">add_relation_object_action</a></code></li>
<li><code><a title="vcd.core.VCD.add_relation_object_object" href="#vcd.core.VCD.add_relation_object_object">add_relation_object_object</a></code></li>
<li><code><a title="vcd.core.VCD.add_relation_subject_object" href="#vcd.core.VCD.add_relation_subject_object">add_relation_subject_object</a></code></li>
<li><code><a title="vcd.core.VCD.add_stream" href="#vcd.core.VCD.add_stream">add_stream</a></code></li>
<li><code><a title="vcd.core.VCD.add_stream_properties" href="#vcd.core.VCD.add_stream_properties">add_stream_properties</a></code></li>
<li><code><a title="vcd.core.VCD.add_transform" href="#vcd.core.VCD.add_transform">add_transform</a></code></li>
<li><code><a title="vcd.core.VCD.convert_to_vcd330" href="#vcd.core.VCD.convert_to_vcd330">convert_to_vcd330</a></code></li>
<li><code><a title="vcd.core.VCD.get_action" href="#vcd.core.VCD.get_action">get_action</a></code></li>
<li><code><a title="vcd.core.VCD.get_action_data" href="#vcd.core.VCD.get_action_data">get_action_data</a></code></li>
<li><code><a title="vcd.core.VCD.get_action_data_frame_intervals" href="#vcd.core.VCD.get_action_data_frame_intervals">get_action_data_frame_intervals</a></code></li>
<li><code><a title="vcd.core.VCD.get_action_uid_by_name" href="#vcd.core.VCD.get_action_uid_by_name">get_action_uid_by_name</a></code></li>
<li><code><a title="vcd.core.VCD.get_actions_with_action_data_name" href="#vcd.core.VCD.get_actions_with_action_data_name">get_actions_with_action_data_name</a></code></li>
<li><code><a title="vcd.core.VCD.get_all" href="#vcd.core.VCD.get_all">get_all</a></code></li>
<li><code><a title="vcd.core.VCD.get_context" href="#vcd.core.VCD.get_context">get_context</a></code></li>
<li><code><a title="vcd.core.VCD.get_context_data" href="#vcd.core.VCD.get_context_data">get_context_data</a></code></li>
<li><code><a title="vcd.core.VCD.get_context_data_frame_intervals" href="#vcd.core.VCD.get_context_data_frame_intervals">get_context_data_frame_intervals</a></code></li>
<li><code><a title="vcd.core.VCD.get_context_uid_by_name" href="#vcd.core.VCD.get_context_uid_by_name">get_context_uid_by_name</a></code></li>
<li><code><a title="vcd.core.VCD.get_contexts_with_context_data_name" href="#vcd.core.VCD.get_contexts_with_context_data_name">get_contexts_with_context_data_name</a></code></li>
<li><code><a title="vcd.core.VCD.get_coordinate_system" href="#vcd.core.VCD.get_coordinate_system">get_coordinate_system</a></code></li>
<li><code><a title="vcd.core.VCD.get_coordinate_systems" href="#vcd.core.VCD.get_coordinate_systems">get_coordinate_systems</a></code></li>
<li><code><a title="vcd.core.VCD.get_data" href="#vcd.core.VCD.get_data">get_data</a></code></li>
<li><code><a title="vcd.core.VCD.get_element" href="#vcd.core.VCD.get_element">get_element</a></code></li>
<li><code><a title="vcd.core.VCD.get_element_data" href="#vcd.core.VCD.get_element_data">get_element_data</a></code></li>
<li><code><a title="vcd.core.VCD.get_element_data_count_per_type" href="#vcd.core.VCD.get_element_data_count_per_type">get_element_data_count_per_type</a></code></li>
<li><code><a title="vcd.core.VCD.get_element_data_frame_intervals" href="#vcd.core.VCD.get_element_data_frame_intervals">get_element_data_frame_intervals</a></code></li>
<li><code><a title="vcd.core.VCD.get_element_data_pointer" href="#vcd.core.VCD.get_element_data_pointer">get_element_data_pointer</a></code></li>
<li><code><a title="vcd.core.VCD.get_element_frame_intervals" href="#vcd.core.VCD.get_element_frame_intervals">get_element_frame_intervals</a></code></li>
<li><code><a title="vcd.core.VCD.get_element_uid_by_name" href="#vcd.core.VCD.get_element_uid_by_name">get_element_uid_by_name</a></code></li>
<li><code><a title="vcd.core.VCD.get_elements_of_type" href="#vcd.core.VCD.get_elements_of_type">get_elements_of_type</a></code></li>
<li><code><a title="vcd.core.VCD.get_elements_uids" href="#vcd.core.VCD.get_elements_uids">get_elements_uids</a></code></li>
<li><code><a title="vcd.core.VCD.get_elements_with_element_data_name" href="#vcd.core.VCD.get_elements_with_element_data_name">get_elements_with_element_data_name</a></code></li>
<li><code><a title="vcd.core.VCD.get_event" href="#vcd.core.VCD.get_event">get_event</a></code></li>
<li><code><a title="vcd.core.VCD.get_event_data" href="#vcd.core.VCD.get_event_data">get_event_data</a></code></li>
<li><code><a title="vcd.core.VCD.get_event_data_frame_intervals" href="#vcd.core.VCD.get_event_data_frame_intervals">get_event_data_frame_intervals</a></code></li>
<li><code><a title="vcd.core.VCD.get_event_uid_by_name" href="#vcd.core.VCD.get_event_uid_by_name">get_event_uid_by_name</a></code></li>
<li><code><a title="vcd.core.VCD.get_events_with_event_data_name" href="#vcd.core.VCD.get_events_with_event_data_name">get_events_with_event_data_name</a></code></li>
<li><code><a title="vcd.core.VCD.get_frame" href="#vcd.core.VCD.get_frame">get_frame</a></code></li>
<li><code><a title="vcd.core.VCD.get_frame_intervals" href="#vcd.core.VCD.get_frame_intervals">get_frame_intervals</a></code></li>
<li><code><a title="vcd.core.VCD.get_frames_with_action_data_name" href="#vcd.core.VCD.get_frames_with_action_data_name">get_frames_with_action_data_name</a></code></li>
<li><code><a title="vcd.core.VCD.get_frames_with_context_data_name" href="#vcd.core.VCD.get_frames_with_context_data_name">get_frames_with_context_data_name</a></code></li>
<li><code><a title="vcd.core.VCD.get_frames_with_element_data_name" href="#vcd.core.VCD.get_frames_with_element_data_name">get_frames_with_element_data_name</a></code></li>
<li><code><a title="vcd.core.VCD.get_frames_with_event_data_name" href="#vcd.core.VCD.get_frames_with_event_data_name">get_frames_with_event_data_name</a></code></li>
<li><code><a title="vcd.core.VCD.get_frames_with_object_data_name" href="#vcd.core.VCD.get_frames_with_object_data_name">get_frames_with_object_data_name</a></code></li>
<li><code><a title="vcd.core.VCD.get_metadata" href="#vcd.core.VCD.get_metadata">get_metadata</a></code></li>
<li><code><a title="vcd.core.VCD.get_num_actions" href="#vcd.core.VCD.get_num_actions">get_num_actions</a></code></li>
<li><code><a title="vcd.core.VCD.get_num_contexts" href="#vcd.core.VCD.get_num_contexts">get_num_contexts</a></code></li>
<li><code><a title="vcd.core.VCD.get_num_elements" href="#vcd.core.VCD.get_num_elements">get_num_elements</a></code></li>
<li><code><a title="vcd.core.VCD.get_num_events" href="#vcd.core.VCD.get_num_events">get_num_events</a></code></li>
<li><code><a title="vcd.core.VCD.get_num_objects" href="#vcd.core.VCD.get_num_objects">get_num_objects</a></code></li>
<li><code><a title="vcd.core.VCD.get_num_relations" href="#vcd.core.VCD.get_num_relations">get_num_relations</a></code></li>
<li><code><a title="vcd.core.VCD.get_object" href="#vcd.core.VCD.get_object">get_object</a></code></li>
<li><code><a title="vcd.core.VCD.get_object_data" href="#vcd.core.VCD.get_object_data">get_object_data</a></code></li>
<li><code><a title="vcd.core.VCD.get_object_data_frame_intervals" href="#vcd.core.VCD.get_object_data_frame_intervals">get_object_data_frame_intervals</a></code></li>
<li><code><a title="vcd.core.VCD.get_object_uid_by_name" href="#vcd.core.VCD.get_object_uid_by_name">get_object_uid_by_name</a></code></li>
<li><code><a title="vcd.core.VCD.get_objects_with_object_data_name" href="#vcd.core.VCD.get_objects_with_object_data_name">get_objects_with_object_data_name</a></code></li>
<li><code><a title="vcd.core.VCD.get_ontology" href="#vcd.core.VCD.get_ontology">get_ontology</a></code></li>
<li><code><a title="vcd.core.VCD.get_relation" href="#vcd.core.VCD.get_relation">get_relation</a></code></li>
<li><code><a title="vcd.core.VCD.get_relation_uid_by_name" href="#vcd.core.VCD.get_relation_uid_by_name">get_relation_uid_by_name</a></code></li>
<li><code><a title="vcd.core.VCD.get_stream" href="#vcd.core.VCD.get_stream">get_stream</a></code></li>
<li><code><a title="vcd.core.VCD.get_streams" href="#vcd.core.VCD.get_streams">get_streams</a></code></li>
<li><code><a title="vcd.core.VCD.has" href="#vcd.core.VCD.has">has</a></code></li>
<li><code><a title="vcd.core.VCD.has_actions" href="#vcd.core.VCD.has_actions">has_actions</a></code></li>
<li><code><a title="vcd.core.VCD.has_contexts" href="#vcd.core.VCD.has_contexts">has_contexts</a></code></li>
<li><code><a title="vcd.core.VCD.has_coordinate_system" href="#vcd.core.VCD.has_coordinate_system">has_coordinate_system</a></code></li>
<li><code><a title="vcd.core.VCD.has_element_data" href="#vcd.core.VCD.has_element_data">has_element_data</a></code></li>
<li><code><a title="vcd.core.VCD.has_elements" href="#vcd.core.VCD.has_elements">has_elements</a></code></li>
<li><code><a title="vcd.core.VCD.has_events" href="#vcd.core.VCD.has_events">has_events</a></code></li>
<li><code><a title="vcd.core.VCD.has_frame" href="#vcd.core.VCD.has_frame">has_frame</a></code></li>
<li><code><a title="vcd.core.VCD.has_objects" href="#vcd.core.VCD.has_objects">has_objects</a></code></li>
<li><code><a title="vcd.core.VCD.has_relations" href="#vcd.core.VCD.has_relations">has_relations</a></code></li>
<li><code><a title="vcd.core.VCD.has_stream" href="#vcd.core.VCD.has_stream">has_stream</a></code></li>
<li><code><a title="vcd.core.VCD.relation_has_frame_intervals" href="#vcd.core.VCD.relation_has_frame_intervals">relation_has_frame_intervals</a></code></li>
<li><code><a title="vcd.core.VCD.reset" href="#vcd.core.VCD.reset">reset</a></code></li>
<li><code><a title="vcd.core.VCD.rm_action" href="#vcd.core.VCD.rm_action">rm_action</a></code></li>
<li><code><a title="vcd.core.VCD.rm_action_by_type" href="#vcd.core.VCD.rm_action_by_type">rm_action_by_type</a></code></li>
<li><code><a title="vcd.core.VCD.rm_context" href="#vcd.core.VCD.rm_context">rm_context</a></code></li>
<li><code><a title="vcd.core.VCD.rm_context_by_type" href="#vcd.core.VCD.rm_context_by_type">rm_context_by_type</a></code></li>
<li><code><a title="vcd.core.VCD.rm_element" href="#vcd.core.VCD.rm_element">rm_element</a></code></li>
<li><code><a title="vcd.core.VCD.rm_element_by_type" href="#vcd.core.VCD.rm_element_by_type">rm_element_by_type</a></code></li>
<li><code><a title="vcd.core.VCD.rm_element_data_from_frames" href="#vcd.core.VCD.rm_element_data_from_frames">rm_element_data_from_frames</a></code></li>
<li><code><a title="vcd.core.VCD.rm_element_data_from_frames_by_name" href="#vcd.core.VCD.rm_element_data_from_frames_by_name">rm_element_data_from_frames_by_name</a></code></li>
<li><code><a title="vcd.core.VCD.rm_event" href="#vcd.core.VCD.rm_event">rm_event</a></code></li>
<li><code><a title="vcd.core.VCD.rm_event_by_type" href="#vcd.core.VCD.rm_event_by_type">rm_event_by_type</a></code></li>
<li><code><a title="vcd.core.VCD.rm_object" href="#vcd.core.VCD.rm_object">rm_object</a></code></li>
<li><code><a title="vcd.core.VCD.rm_object_by_type" href="#vcd.core.VCD.rm_object_by_type">rm_object_by_type</a></code></li>
<li><code><a title="vcd.core.VCD.rm_relation" href="#vcd.core.VCD.rm_relation">rm_relation</a></code></li>
<li><code><a title="vcd.core.VCD.rm_relation_by_type" href="#vcd.core.VCD.rm_relation_by_type">rm_relation_by_type</a></code></li>
<li><code><a title="vcd.core.VCD.save" href="#vcd.core.VCD.save">save</a></code></li>
<li><code><a title="vcd.core.VCD.save_frame" href="#vcd.core.VCD.save_frame">save_frame</a></code></li>
<li><code><a title="vcd.core.VCD.set_use_uuid" href="#vcd.core.VCD.set_use_uuid">set_use_uuid</a></code></li>
<li><code><a title="vcd.core.VCD.stringify" href="#vcd.core.VCD.stringify">stringify</a></code></li>
<li><code><a title="vcd.core.VCD.stringify_frame" href="#vcd.core.VCD.stringify_frame">stringify_frame</a></code></li>
<li><code><a title="vcd.core.VCD.validate" href="#vcd.core.VCD.validate">validate</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>